import {
  require_axios,
  require_dist as require_dist3,
  require_lib
} from "./chunk-UTGWBI5N.js";
import {
  require_utils
} from "./chunk-KVZWYLU7.js";
import {
  require_dist as require_dist2
} from "./chunk-XZ6B2NFE.js";
import {
  require_dist
} from "./chunk-LKNDHCNV.js";
import "./chunk-KQLZCHIZ.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-Y7S7B2N7.js";

// browser-external:@pinata/sdk
var require_sdk = __commonJS({
  "browser-external:@pinata/sdk"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "@pinata/sdk" has been externalized for browser compatibility. Cannot access "@pinata/sdk.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@ton-community/assets-sdk/dist/storage/pinata.js
var require_pinata = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/storage/pinata.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PinataStorage = void 0;
    var utils_1 = require_utils();
    var PinataStorage = class _PinataStorage {
      constructor(apiKey, secretApiKey) {
        this.client = (0, utils_1.defer)(async () => {
          const pinata = await Promise.resolve().then(() => __importStar(require_sdk())).then((m) => m.default);
          return new pinata(this.apiKey, this.secretApiKey);
        });
        this.stream = (0, utils_1.defer)(async (contents) => {
          const stream = await Promise.resolve().then(() => __importStar(require_stream())).then((m) => m.Readable);
          return stream.from(contents);
        });
        this.apiKey = apiKey;
        this.secretApiKey = secretApiKey;
      }
      static create(params) {
        return new _PinataStorage(params.pinataApiKey, params.pinataSecretKey);
      }
      async uploadFile(contents) {
        const client = await this.client();
        const stream = await this.stream(contents);
        const result = await client.pinFileToIPFS(stream, {
          pinataMetadata: {
            name: "Assets SDK Jetton"
          }
        });
        return "ipfs://" + result.IpfsHash;
      }
    };
    exports.PinataStorage = PinataStorage;
  }
});

// browser-external:@aws-sdk/client-s3
var require_client_s3 = __commonJS({
  "browser-external:@aws-sdk/client-s3"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "@aws-sdk/client-s3" has been externalized for browser compatibility. Cannot access "@aws-sdk/client-s3.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@ton-community/assets-sdk/dist/storage/s3.js
var require_s3 = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/storage/s3.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.S3Storage = void 0;
    var utils_1 = require_utils();
    var S3Storage = class _S3Storage {
      constructor(accessKeyId, secretAccessKey, bucket) {
        this.s3 = (0, utils_1.defer)(async () => {
          const s3 = await Promise.resolve().then(() => __importStar(require_client_s3())).then((m) => m.S3);
          return new s3({
            credentials: {
              accessKeyId: this.accessKeyId,
              secretAccessKey: this.secretAccessKey
            }
          });
        });
        this.accessKeyId = accessKeyId;
        this.secretAccessKey = secretAccessKey;
        this.bucket = bucket;
      }
      static create(params) {
        return new _S3Storage(params.s3AccessKeyId, params.s3SecretAccessKey, params.s3Bucket);
      }
      async uploadFile(contents) {
        const s3 = await this.s3();
        const key = "jetton/" + Math.random().toString(36).substring(2);
        await s3.putObject({
          Bucket: this.bucket,
          Key: key,
          Body: contents
        });
        return "https://" + this.bucket + ".s3.amazonaws.com/" + key;
      }
    };
    exports.S3Storage = S3Storage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/content.js
var require_content = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/content.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferToStr = exports.decodeImage = exports.decodeSimpleFields = exports.loadFullContent = exports.DefaultContentResolver = void 0;
    var core_1 = require_dist2();
    var crypto_1 = require_dist();
    var DefaultContentResolver = class {
      constructor(ipfsGateway) {
        this.ipfsGateway = ipfsGateway ?? ((id) => `https://ipfs.io/ipfs/${id}`);
      }
      async resolve(url) {
        if (url.startsWith("ipfs://")) {
          url = this.ipfsGateway(url.slice(7));
        }
        if (!(url.startsWith("https://") || url.startsWith("http://"))) {
          throw new Error("Unknown URL: " + url);
        }
        return Buffer.from(await (await fetch(url)).arrayBuffer());
      }
    };
    exports.DefaultContentResolver = DefaultContentResolver;
    function loadSnake(s) {
      const b = [];
      while (s.remainingBits > 0 || s.remainingRefs > 0) {
        if (s.remainingBits % 8 !== 0) {
          throw new Error("Slice must contain an integer number of bytes");
        }
        b.push(s.loadBuffer(s.remainingBits / 8));
        if (s.remainingRefs === 1) {
          s = s.loadRef().beginParse();
        } else if (s.remainingRefs > 1) {
          throw new Error("Slice must contain at most 1 ref");
        }
      }
      return Buffer.concat(b);
    }
    var BufferValue = {
      serialize: () => {
        throw new Error("Buffer serialization is not supported");
      },
      parse: (src) => {
        const r = src.loadRef().beginParse();
        if (r.remainingBits % 8 !== 0) {
          throw new Error("Slice must contain an integer number of bytes");
        }
        if (r.remainingRefs !== 0) {
          throw new Error("Slice must not contain refs");
        }
        return r.loadBuffer(r.remainingBits / 8);
      }
    };
    function loadChunked(s) {
      const d = s.loadDict(core_1.Dictionary.Keys.Uint(32), BufferValue);
      const b = [];
      for (let i = 0; i < d.size; i++) {
        const cb = d.get(i);
        if (cb === void 0) {
          throw new Error("Dict must contain sequential keys");
        }
        b.push(cb);
      }
      return Buffer.concat(b);
    }
    var ContentDataValue = {
      serialize: () => {
        throw new Error("ContentData serialization is not supported");
      },
      parse: (src) => {
        const r = src.loadRef().beginParse();
        const type = r.loadUint(8);
        if (type === 0) {
          return loadSnake(r);
        } else if (type === 1) {
          return loadChunked(r);
        } else {
          throw new Error("Unknown ContentData type: " + type);
        }
      }
    };
    function bufferToObj(b) {
      const parsed = JSON.parse(b.toString("utf-8"));
      if (typeof parsed !== "object") {
        throw new Error("Data must be an object");
      }
      return parsed;
    }
    function hashKey(key) {
      return BigInt("0x" + (0, crypto_1.sha256_sync)(key).toString("hex"));
    }
    async function loadFullContent(data, contentResolver) {
      const ds = data.beginParse();
      const type = ds.loadUint(8);
      if (type === 0) {
        const data2 = ds.loadDict(core_1.Dictionary.Keys.BigUint(256), ContentDataValue);
        const uri = data2.get(hashKey("uri"));
        if (uri !== void 0) {
          const uriStr = uri.toString("utf-8");
          const offchain = await contentResolver.resolve(uriStr);
          return {
            type: "semichain",
            offchainFields: bufferToObj(offchain),
            onchainFields: data2,
            offchainUrl: uriStr
          };
        }
        return {
          type: "onchain",
          onchainFields: data2
        };
      } else if (type === 1) {
        const uri = ds.loadStringTail();
        const data2 = await contentResolver.resolve(uri);
        return {
          type: "offchain",
          offchainFields: bufferToObj(data2),
          offchainUrl: uri
        };
      } else {
        throw new Error("Unknown FullContent type: " + type);
      }
    }
    exports.loadFullContent = loadFullContent;
    function decodeSimpleFields(dc, parsers) {
      const out = {};
      for (const k in parsers) {
        if (dc.onchainFields !== void 0) {
          const h = hashKey(k);
          const v = dc.onchainFields.get(h);
          if (v !== void 0) {
            out[k] = parsers[k].onchain(v);
            dc.onchainFields.delete(h);
            continue;
          }
        }
        if (dc.offchainFields !== void 0) {
          if (k in dc.offchainFields) {
            out[k] = parsers[k].offchain(dc.offchainFields[k]);
            delete dc.offchainFields[k];
          }
        }
      }
      return out;
    }
    exports.decodeSimpleFields = decodeSimpleFields;
    function decodeImage(dc) {
      if (dc.onchainFields !== void 0 && dc.onchainFields.has(hashKey("image")) && dc.onchainFields.has(hashKey("image_data"))) {
        throw new Error("Onchain fields contain both image and image_data");
      }
      if (dc.offchainFields !== void 0 && "image" in dc.offchainFields && "image_data" in dc.offchainFields) {
        throw new Error("Offchain fields contain both image and image_data");
      }
      if (dc.onchainFields !== void 0) {
        const image = dc.onchainFields.get(hashKey("image"));
        if (image !== void 0) {
          dc.onchainFields.delete(hashKey("image"));
          return image.toString("utf-8");
        }
        const imageData = dc.onchainFields.get(hashKey("image_data"));
        if (imageData !== void 0) {
          dc.onchainFields.delete(hashKey("image_data"));
          return imageData;
        }
      }
      if (dc.offchainFields !== void 0) {
        if ("image" in dc.offchainFields) {
          const image = dc.offchainFields.image;
          if (typeof image !== "string") {
            throw new Error("Image URI must be a string");
          }
          delete dc.offchainFields.image;
          return image;
        }
        if ("image_data" in dc.offchainFields) {
          const imageData = dc.offchainFields.image_data;
          if (typeof imageData !== "string") {
            throw new Error("Offchain image data must be a string");
          }
          delete dc.offchainFields.image_data;
          return Buffer.from(imageData, "base64");
        }
      }
      return void 0;
    }
    exports.decodeImage = decodeImage;
    var bufferToStr = (b) => b.toString("utf-8");
    exports.bufferToStr = bufferToStr;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/content.js
var require_content2 = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/content.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJettonContent = exports.jettonContentToInternal = void 0;
    var core_1 = require_dist2();
    var zod_1 = __importDefault(require_lib());
    var content_1 = require_content();
    function jettonContentToInternal(content) {
      var _a, _b;
      return {
        uri: content.uri,
        name: content.name,
        description: content.description,
        image: content.image,
        image_data: (_a = content.imageData) == null ? void 0 : _a.toString("base64"),
        symbol: content.symbol,
        decimals: (_b = content.decimals) == null ? void 0 : _b.toString(),
        amount_style: content.amountStyle,
        render_type: content.renderType
      };
    }
    exports.jettonContentToInternal = jettonContentToInternal;
    function parseJettonContent(dc) {
      const decoded = (0, content_1.decodeSimpleFields)(dc, {
        name: {
          onchain: content_1.bufferToStr,
          offchain: (v) => zod_1.default.string().parse(v)
        },
        description: {
          onchain: content_1.bufferToStr,
          offchain: (v) => zod_1.default.string().parse(v)
        },
        symbol: {
          onchain: content_1.bufferToStr,
          offchain: (v) => zod_1.default.string().parse(v)
        },
        decimals: {
          onchain: (v) => parseInt((0, content_1.bufferToStr)(v)),
          offchain: (v) => zod_1.default.union([zod_1.default.string(), zod_1.default.number()]).transform((v2) => Number(v2)).parse(v)
        },
        amount_style: {
          onchain: (v) => {
            const s = (0, content_1.bufferToStr)(v);
            if (!["n", "n-of-total", "%"].includes(s)) {
              throw new Error("Unknown amount_style: " + s);
            }
            return s;
          },
          offchain: (v) => zod_1.default.union([zod_1.default.literal("n"), zod_1.default.literal("n-of-total"), zod_1.default.literal("%")]).parse(v)
        },
        render_type: {
          onchain: (v) => {
            const s = (0, content_1.bufferToStr)(v);
            if (!["currency", "game"].includes(s)) {
              throw new Error("Unknown render_type: " + s);
            }
            return s;
          },
          offchain: (v) => zod_1.default.union([zod_1.default.literal("currency"), zod_1.default.literal("game")]).parse(v)
        }
      });
      decoded.image = (0, content_1.decodeImage)(dc);
      const out = {
        ...decoded,
        type: dc.type,
        unknownOffchainFields: dc.offchainFields ?? {},
        unknownOnchainFields: dc.onchainFields ?? core_1.Dictionary.empty(),
        offchainUrl: dc.offchainUrl
      };
      return out;
    }
    exports.parseJettonContent = parseJettonContent;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/content.js
var require_content3 = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/content.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseNftContent = exports.nftContentToInternal = void 0;
    var core_1 = require_dist2();
    var zod_1 = __importDefault(require_lib());
    var content_1 = require_content();
    function nftContentToInternal(content) {
      var _a;
      return {
        uri: content.uri,
        name: content.name,
        description: content.description,
        image: content.image,
        image_data: (_a = content.imageData) == null ? void 0 : _a.toString("base64")
      };
    }
    exports.nftContentToInternal = nftContentToInternal;
    function parseNftContent(dc) {
      const decoded = (0, content_1.decodeSimpleFields)(dc, {
        name: {
          onchain: content_1.bufferToStr,
          offchain: (v) => zod_1.default.string().parse(v)
        },
        description: {
          onchain: content_1.bufferToStr,
          offchain: (v) => zod_1.default.string().parse(v)
        }
      });
      decoded.image = (0, content_1.decodeImage)(dc);
      const out = {
        ...decoded,
        type: dc.type,
        unknownOffchainFields: dc.offchainFields ?? {},
        unknownOnchainFields: dc.onchainFields ?? core_1.Dictionary.empty(),
        offchainUrl: dc.offchainUrl
      };
      return out;
    }
    exports.parseNftContent = parseNftContent;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/contracts/build/jetton-wallet.js
var require_jetton_wallet = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/contracts/build/jetton-wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jettonWalletCode = void 0;
    exports.jettonWalletCode = {
      codeBoc: "te6ccgECEgEAAzQAART/APSkE/S88sgLAQIBYgIDAgLMBAUAG6D2BdqJofQB9IH0gahhAgHUBgcCAUgICQDDCDHAJJfBOAB0NMDAXGwlRNfA/AL4PpA+kAx+gAxcdch+gAx+gAwc6m0AALTH4IQD4p+pVIgupUxNFnwCOCCEBeNRRlSILqWMUREA/AJ4DWCEFlfB7y6k1nwCuBfBIQP8vCAAET6RDBwuvLhTYAIBIAoLAgEgEBEB8QD0z/6APpAIfAB7UTQ+gD6QPpA1DBRNqFSKscF8uLBKML/8uLCVDRCcFQgE1QUA8hQBPoCWM8WAc8WzMkiyMsBEvQA9ADLAMkg+QBwdMjLAsoHy//J0AT6QPQEMfoAINdJwgDy4sR3gBjIywVQCM8WcPoCF8trE8yAMA/c7UTQ+gD6QPpA1DAI0z/6AFFRoAX6QPpAU1vHBVRzbXBUIBNUFAPIUAT6AljPFgHPFszJIsjLARL0APQAywDJ+QBwdMjLAsoHy//J0FANxwUcsfLiwwr6AFGooYIImJaAggiYloAStgihggjk4cCgGKEn4w8l1wsBwwAjgDQ4PAK6CEBeNRRnIyx8Zyz9QB/oCIs8WUAbPFiX6AlADzxbJUAXMI5FykXHiUAioE6CCCOThwKoAggiYloCgoBS88uLFBMmAQPsAECPIUAT6AljPFgHPFszJ7VQAcFJ5oBihghBzYtCcyMsfUjDLP1j6AlAHzxZQB88WyXGAEMjLBSTPFlAG+gIVy2oUzMlx+wAQJBAjAA4QSRA4N18EAHbCALCOIYIQ1TJ223CAEMjLBVAIzxZQBPoCFstqEssfEss/yXL7AJM1bCHiA8hQBPoCWM8WAc8WzMntVADbO1E0PoA+kD6QNQwB9M/+gD6QDBRUaFSSccF8uLBJ8L/8uLCggjk4cCqABagFrzy4sOCEHvdl97Iyx8Vyz9QA/oCIs8WAc8WyXGAGMjLBSTPFnD6AstqzMmAQPsAQBPIUAT6AljPFgHPFszJ7VSAAgyAINch7UTQ+gD6QPpA1DAE0x+CEBeNRRlSILqCEHvdl94TuhKx8uLF0z8x+gAwE6BQI8hQBPoCWM8WAc8WzMntVIA=="
    };
  }
});

// node_modules/@ton-community/assets-sdk/dist/common/types.js
var require_types = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/common/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseExcessReturnOptions = exports.parseNotifyOptions = void 0;
    var core_1 = require_dist2();
    function parseNotifyOptions(options) {
      if (options === false) {
        return null;
      }
      if (typeof options === "object") {
        return {
          amount: options.amount ?? (0, core_1.toNano)("0.01"),
          payload: options.payload ?? null
        };
      }
      return {
        amount: (0, core_1.toNano)("0.01"),
        payload: null
      };
    }
    exports.parseNotifyOptions = parseNotifyOptions;
    function parseExcessReturnOptions(options, sender) {
      if (options === false) {
        return null;
      }
      if (typeof options === "object") {
        return {
          address: options.address ?? sender.address
        };
      }
      return {
        address: sender.address
      };
    }
    exports.parseExcessReturnOptions = parseExcessReturnOptions;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/opcodes.js
var require_opcodes = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/opcodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JETTON_EXCESSES_OPCODE = exports.JETTON_BURN_NOTIFICATION_OPCODE = exports.JETTON_BURN_OPCODE = exports.JETTON_TRANSFER_NOTIFICATION_OPCODE = exports.JETTON_TRANSFER_OPCODE = exports.JETTON_CHANGE_CONTENT_OPCODE = exports.JETTON_CHANGE_ADMIN_OPCODE = exports.JETTON_INTERNAL_TRANSFER_OPCODE = exports.JETTON_MINT_OPCODE = void 0;
    exports.JETTON_MINT_OPCODE = 21;
    exports.JETTON_INTERNAL_TRANSFER_OPCODE = 395134233;
    exports.JETTON_CHANGE_ADMIN_OPCODE = 3;
    exports.JETTON_CHANGE_CONTENT_OPCODE = 4;
    exports.JETTON_TRANSFER_OPCODE = 260734629;
    exports.JETTON_TRANSFER_NOTIFICATION_OPCODE = 1935855772;
    exports.JETTON_BURN_OPCODE = 1499400124;
    exports.JETTON_BURN_NOTIFICATION_OPCODE = 2078119902;
    exports.JETTON_EXCESSES_OPCODE = 3576854235;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonTransferMessage.js
var require_JettonTransferMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonTransferMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonTransferMessage = exports.storeJettonTransferMessage = void 0;
    var opcodes_1 = require_opcodes();
    function storeJettonTransferMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.JETTON_TRANSFER_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeCoins(src.amount);
        builder.storeAddress(src.destination);
        builder.storeAddress(src.responseDestination);
        builder.storeMaybeRef(src.customPayload);
        builder.storeCoins(src.forwardAmount ?? 0);
        builder.storeMaybeRef(src.forwardPayload);
      };
    }
    exports.storeJettonTransferMessage = storeJettonTransferMessage;
    function loadJettonTransferMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.JETTON_TRANSFER_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const amount = slice.loadCoins();
      const to = slice.loadAddress();
      const responseDestination = slice.loadMaybeAddress();
      const customPayload = slice.loadMaybeRef();
      const forwardAmount = slice.loadCoins();
      const eitherPayload = slice.loadBoolean();
      const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
      return {
        queryId,
        amount,
        destination: to,
        responseDestination,
        customPayload,
        forwardAmount,
        forwardPayload
      };
    }
    exports.loadJettonTransferMessage = loadJettonTransferMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonBurnMessage.js
var require_JettonBurnMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonBurnMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonBurnMessage = exports.storeJettonBurnMessage = void 0;
    var opcodes_1 = require_opcodes();
    function storeJettonBurnMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.JETTON_BURN_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeCoins(src.amount);
        builder.storeAddress(src.responseDestination);
        builder.storeMaybeRef(src.customPayload);
      };
    }
    exports.storeJettonBurnMessage = storeJettonBurnMessage;
    function loadJettonBurnMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.JETTON_BURN_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const amount = slice.loadCoins();
      const responseDestination = slice.loadMaybeAddress();
      const customPayload = slice.loadMaybeRef();
      return {
        queryId,
        amount,
        responseDestination,
        customPayload
      };
    }
    exports.loadJettonBurnMessage = loadJettonBurnMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonInternalTransferMessage.js
var require_JettonInternalTransferMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonInternalTransferMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonInternalTransferMessage = exports.storeJettonInternalTransferMessage = void 0;
    var opcodes_1 = require_opcodes();
    function storeJettonInternalTransferMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeCoins(src.amount);
        builder.storeAddress(src.from);
        builder.storeAddress(src.responseAddress);
        builder.storeCoins(src.forwardTonAmount);
        builder.storeMaybeRef(src.forwardPayload);
      };
    }
    exports.storeJettonInternalTransferMessage = storeJettonInternalTransferMessage;
    function loadJettonInternalTransferMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const amount = slice.loadCoins();
      const from = slice.loadAddress();
      const responseAddress = slice.loadAddress();
      const forwardTonAmount = slice.loadCoins();
      const eitherPayload = slice.loadBoolean();
      const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
      return {
        queryId,
        amount,
        from,
        responseAddress,
        forwardTonAmount,
        forwardPayload
      };
    }
    exports.loadJettonInternalTransferMessage = loadJettonInternalTransferMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonBurnNotificationMessage.js
var require_JettonBurnNotificationMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonBurnNotificationMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonBurnNotificationMessage = exports.storeJettonBurnNotificationMessage = void 0;
    var opcodes_1 = require_opcodes();
    function storeJettonBurnNotificationMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.JETTON_BURN_NOTIFICATION_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeCoins(src.amount);
        builder.storeAddress(src.sender);
        builder.storeAddress(src.responseDestination);
      };
    }
    exports.storeJettonBurnNotificationMessage = storeJettonBurnNotificationMessage;
    function loadJettonBurnNotificationMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.JETTON_BURN_NOTIFICATION_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const amount = slice.loadCoins();
      const sender = slice.loadAddress();
      const responseDestination = slice.loadMaybeAddress();
      return {
        queryId,
        amount,
        sender,
        responseDestination
      };
    }
    exports.loadJettonBurnNotificationMessage = loadJettonBurnNotificationMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonTransferNotificationMessage.js
var require_JettonTransferNotificationMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonTransferNotificationMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonTransferNotificationMessage = exports.storeJettonTransferNotificationMessage = void 0;
    var opcodes_1 = require_opcodes();
    function storeJettonTransferNotificationMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.JETTON_TRANSFER_NOTIFICATION_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeCoins(src.amount);
        builder.storeAddress(src.sender);
        builder.storeMaybeRef(src.forwardPayload);
      };
    }
    exports.storeJettonTransferNotificationMessage = storeJettonTransferNotificationMessage;
    function loadJettonTransferNotificationMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.JETTON_TRANSFER_NOTIFICATION_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const amount = slice.loadCoins();
      const sender = slice.loadAddress();
      const eitherPayload = slice.loadBoolean();
      const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
      return {
        queryId,
        amount,
        sender,
        forwardPayload
      };
    }
    exports.loadJettonTransferNotificationMessage = loadJettonTransferNotificationMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonWalletMessage.js
var require_JettonWalletMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonWalletMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonWalletMessage = void 0;
    var opcodes_1 = require_opcodes();
    var JettonTransferMessage_1 = require_JettonTransferMessage();
    var JettonInternalTransferMessage_1 = require_JettonInternalTransferMessage();
    var JettonBurnMessage_1 = require_JettonBurnMessage();
    var JettonBurnNotificationMessage_1 = require_JettonBurnNotificationMessage();
    var JettonTransferNotificationMessage_1 = require_JettonTransferNotificationMessage();
    function loadJettonWalletMessage(slice) {
      try {
        const opcode = slice.preloadUint(32);
        switch (opcode) {
          case opcodes_1.JETTON_TRANSFER_OPCODE:
            return { kind: "jetton_transfer", ...(0, JettonTransferMessage_1.loadJettonTransferMessage)(slice) };
          case opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE:
            return { kind: "jetton_internal_transfer", ...(0, JettonInternalTransferMessage_1.loadJettonInternalTransferMessage)(slice) };
          case opcodes_1.JETTON_TRANSFER_NOTIFICATION_OPCODE:
            return { kind: "transfer_notification", ...(0, JettonTransferNotificationMessage_1.loadJettonTransferNotificationMessage)(slice) };
          case opcodes_1.JETTON_BURN_OPCODE:
            return { kind: "jetton_burn", ...(0, JettonBurnMessage_1.loadJettonBurnMessage)(slice) };
          case opcodes_1.JETTON_BURN_NOTIFICATION_OPCODE:
            return { kind: "jetton_burn_notification", ...(0, JettonBurnNotificationMessage_1.loadJettonBurnNotificationMessage)(slice) };
          case opcodes_1.JETTON_EXCESSES_OPCODE:
            return { kind: "excesses", ...{ queryId: slice.loadUintBig(64) } };
        }
      } catch (e) {
      }
      return { kind: "unknown" };
    }
    exports.loadJettonWalletMessage = loadJettonWalletMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/common/types/TransferMessage.js
var require_TransferMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/common/types/TransferMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadTransferMessage = exports.loadEncryptedMessage = exports.storeEncryptedMessage = exports.loadTextMessage = exports.storeTextMessage = exports.loadSimpleTransferMessage = exports.storeSimpleTransferMessage = exports.ENCRYPTED_MESSAGE_OPCODE = exports.TEXT_OPCODE = void 0;
    exports.TEXT_OPCODE = 0;
    exports.ENCRYPTED_MESSAGE_OPCODE = 560454219;
    function storeSimpleTransferMessage(value) {
      return (builder) => {
      };
    }
    exports.storeSimpleTransferMessage = storeSimpleTransferMessage;
    function loadSimpleTransferMessage(slice) {
      return {};
    }
    exports.loadSimpleTransferMessage = loadSimpleTransferMessage;
    function storeTextMessage(value) {
      return (builder) => {
        builder.storeUint(0, 32);
        builder.storeStringTail(value.text);
      };
    }
    exports.storeTextMessage = storeTextMessage;
    function loadTextMessage(slice) {
      if (slice.loadUint(32) !== 0) {
        throw new Error("Wrong opcode");
      }
      return { text: slice.loadStringTail() };
    }
    exports.loadTextMessage = loadTextMessage;
    function storeEncryptedMessage(value) {
      return (builder) => {
        builder.storeUint(exports.ENCRYPTED_MESSAGE_OPCODE, 32);
        builder.storeStringTail(value.data.toString("utf-8"));
      };
    }
    exports.storeEncryptedMessage = storeEncryptedMessage;
    function loadEncryptedMessage(slice) {
      if (slice.loadUint(32) !== exports.ENCRYPTED_MESSAGE_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const data = slice.loadStringTail();
      return { data: Buffer.from(data, "utf-8") };
    }
    exports.loadEncryptedMessage = loadEncryptedMessage;
    function loadTransferMessage(slice) {
      if (slice.remainingBits === 0) {
        return { kind: "simple_transfer" };
      }
      try {
        const opcode = slice.preloadUint(32);
        switch (opcode) {
          case exports.TEXT_OPCODE:
            return { kind: "text_message", ...loadTextMessage(slice) };
          case exports.ENCRYPTED_MESSAGE_OPCODE:
            return { kind: "encrypted_message", ...loadEncryptedMessage(slice) };
        }
      } catch (e) {
      }
      return { kind: "unknown" };
    }
    exports.loadTransferMessage = loadTransferMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/common/types/TransferAction.js
var require_TransferAction = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/common/types/TransferAction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTransferTransaction = void 0;
    var TransferMessage_1 = require_TransferMessage();
    function parseTransferTransaction(tx) {
      if (tx.description.type !== "generic") {
        return { kind: "unknown", transaction: tx };
      }
      if (!tx.inMessage) {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.inMessage.info.type !== "internal") {
        return { kind: "unknown", transaction: tx };
      }
      const body = tx.inMessage.body.beginParse();
      const inMessage = (0, TransferMessage_1.loadTransferMessage)(body);
      if (inMessage.kind === "simple_transfer") {
        return {
          kind: "simple_transfer",
          from: tx.inMessage.info.src,
          to: tx.inMessage.info.dest,
          amount: tx.inMessage.info.value.coins,
          transaction: tx
        };
      }
      if (inMessage.kind === "text_message") {
        return {
          kind: "text_message",
          from: tx.inMessage.info.src,
          to: tx.inMessage.info.dest,
          amount: tx.inMessage.info.value.coins,
          text: inMessage.text,
          transaction: tx
        };
      }
      if (inMessage.kind === "encrypted_message") {
        return {
          kind: "encrypted_message",
          from: tx.inMessage.info.src,
          to: tx.inMessage.info.dest,
          amount: tx.inMessage.info.value.coins,
          data: inMessage.data,
          transaction: tx
        };
      }
      return { kind: "unknown", transaction: tx };
    }
    exports.parseTransferTransaction = parseTransferTransaction;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonWalletAction.js
var require_JettonWalletAction = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonWalletAction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJettonWalletTransaction = void 0;
    var JettonWalletMessage_1 = require_JettonWalletMessage();
    var TransferAction_1 = require_TransferAction();
    function parseJettonWalletTransaction(tx) {
      const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
      if (mayBeTransfer.kind !== "unknown") {
        return mayBeTransfer;
      }
      if (tx.description.type !== "generic") {
        return { kind: "unknown", transaction: tx };
      }
      if (!tx.inMessage) {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.inMessage.info.type !== "internal") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.type !== "vm") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.exitCode !== 0) {
        return { kind: "unknown", transaction: tx };
      }
      if (!tx.inMessage.body) {
        return { kind: "unknown", transaction: tx };
      }
      const isBounced = tx.inMessage.info.bounced;
      const inMessage = (0, JettonWalletMessage_1.loadJettonWalletMessage)(tx.inMessage.body.beginParse());
      if (inMessage.kind === "jetton_transfer") {
        return {
          kind: "jetton_transfer",
          queryId: inMessage.queryId,
          from: tx.inMessage.info.src,
          to: inMessage.destination,
          amount: inMessage.amount,
          responseAddress: inMessage.responseDestination,
          forwardTonAmount: inMessage.forwardAmount,
          forwardPayload: inMessage.forwardPayload,
          transaction: tx
        };
      }
      if (isBounced && inMessage.kind === "jetton_internal_transfer") {
        return {
          kind: "jetton_transfer_failed",
          queryId: inMessage.queryId,
          amount: inMessage.amount,
          transaction: tx
        };
      }
      if (inMessage.kind === "jetton_internal_transfer") {
        return {
          kind: "jetton_transfer_received",
          queryId: inMessage.queryId,
          amount: inMessage.amount,
          from: tx.inMessage.info.src,
          transaction: tx
        };
      }
      if (inMessage.kind === "jetton_burn") {
        return {
          kind: "jetton_burn",
          queryId: inMessage.queryId,
          amount: inMessage.amount,
          transaction: tx
        };
      }
      if (isBounced && inMessage.kind === "jetton_burn_notification") {
        return {
          kind: "jetton_burn_failed",
          queryId: inMessage.queryId,
          amount: inMessage.amount,
          transaction: tx
        };
      }
      return { kind: "unknown", transaction: tx };
    }
    exports.parseJettonWalletTransaction = parseJettonWalletTransaction;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/JettonWallet.js
var require_JettonWallet = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/JettonWallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JettonWallet = exports.jettonWalletConfigToCell = void 0;
    var core_1 = require_dist2();
    var jetton_wallet_1 = require_jetton_wallet();
    var types_1 = require_types();
    var JettonTransferMessage_1 = require_JettonTransferMessage();
    var JettonBurnMessage_1 = require_JettonBurnMessage();
    var JettonWalletAction_1 = require_JettonWalletAction();
    function jettonWalletConfigToCell(config) {
      return (0, core_1.beginCell)().storeCoins(config.balance).storeAddress(config.owner).storeAddress(config.jettonMaster).storeRef(config.jettonWalletCode).endCell();
    }
    exports.jettonWalletConfigToCell = jettonWalletConfigToCell;
    var JettonWallet = class _JettonWallet {
      constructor(address, init) {
        this.address = address;
        this.init = init;
      }
      static createFromConfig(config, code, workchain) {
        const data = jettonWalletConfigToCell({
          balance: 0n,
          owner: config.owner,
          jettonMaster: config.jettonMaster,
          jettonWalletCode: code ?? _JettonWallet.code
        });
        const init = { data, code: code ?? _JettonWallet.code };
        return new _JettonWallet((0, core_1.contractAddress)(workchain ?? 0, init), init);
      }
      static createFromAddress(address) {
        return new _JettonWallet(address);
      }
      async sendDeploy(provider, sender, value) {
        await provider.internal(sender, {
          value: value ?? (0, core_1.toNano)("0.05"),
          bounce: true
        });
      }
      async send(provider, sender, recipient, amount, options) {
        const notification = (0, types_1.parseNotifyOptions)(options == null ? void 0 : options.notify);
        const excessReturn = (0, types_1.parseExcessReturnOptions)(options == null ? void 0 : options.returnExcess, sender);
        await provider.internal(sender, {
          value: ((options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05")) + ((notification == null ? void 0 : notification.amount) ?? 0n),
          bounce: true,
          sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
          body: (0, core_1.beginCell)().store((0, JettonTransferMessage_1.storeJettonTransferMessage)({
            queryId: (options == null ? void 0 : options.queryId) ?? 0n,
            amount,
            destination: recipient,
            responseDestination: (excessReturn == null ? void 0 : excessReturn.address) ?? null,
            customPayload: (options == null ? void 0 : options.customPayload) ?? null,
            forwardAmount: (notification == null ? void 0 : notification.amount) ?? 0n,
            forwardPayload: (notification == null ? void 0 : notification.payload) ?? null
          })).endCell()
        });
      }
      async sendBurn(provider, sender, amount, options) {
        const excessReturn = (0, types_1.parseExcessReturnOptions)(options == null ? void 0 : options.returnExcess, sender);
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
          body: (0, core_1.beginCell)().store((0, JettonBurnMessage_1.storeJettonBurnMessage)({
            queryId: (options == null ? void 0 : options.queryId) ?? 0n,
            amount,
            responseDestination: (excessReturn == null ? void 0 : excessReturn.address) ?? null,
            customPayload: (options == null ? void 0 : options.customPayload) ?? null
          })).endCell()
        });
      }
      async getData(provider) {
        const { stack } = await provider.get("get_wallet_data", []);
        return {
          balance: stack.readBigNumber(),
          owner: stack.readAddress(),
          jettonMaster: stack.readAddress(),
          jettonWalletCode: stack.readCell()
        };
      }
      async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
          const state = await provider.getState();
          if (!state.last) {
            return [];
          }
          lt = state.last.lt;
          hash = state.last.hash;
        }
        const transactions = await provider.getTransactions(this.address, lt, hash, limit);
        return transactions.map((tx) => (0, JettonWalletAction_1.parseJettonWalletTransaction)(tx));
      }
    };
    exports.JettonWallet = JettonWallet;
    JettonWallet.code = core_1.Cell.fromBase64(jetton_wallet_1.jettonWalletCode.codeBoc);
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/contracts/build/jetton-minter.js
var require_jetton_minter = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/contracts/build/jetton-minter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jettonMinterCode = void 0;
    exports.jettonMinterCode = {
      codeBoc: "te6ccgECDgEAAqMAART/APSkE/S88sgLAQIBYgIDAgLMBAUCA3pgDA0B9dkGOASS+B8ADoaYGAuNhJL4HwfSB9IBj9ABi465D9ABj9ABg51NoAAWmP6Z/2omh9AH0gamoYQAqpOF1HGZqamxsommOC+XAkgX0gfQBqGBBoQDBrkP0AGBKIGigheASKUCgZ5CgCfQEsZ4tmZmT2qnBBCD3uy+8pOF1AYAk7PwUIgG4KhAJqgoB5CgCfQEsZ4sA54tmZJFkZYCJegB6AGWAZJB8gDg6ZGWBZQPl/+ToO8AMZGWCrGeLKAJ9AQnltYlmZmS4/YBBPSO4DY3NwH6APpA+ChUEgZwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAyfkAcHTIywLKB8v/ydBQBscF8uBKoQNFRchQBPoCWM8WzMzJ7VQB+kAwINcLAcMAkVvjDeCCECx2uXNScLrjAjU3NyPAA+MCNQLABAcICQoAPoIQ1TJ223CAEMjLBVADzxYi+gISy2rLH8s/yYBC+wAB/jZfA4IImJaAFaAVvPLgSwL6QNMAMJXIIc8WyZFt4oIQ0XNUAHCAGMjLBVAFzxYk+gIUy2oTyx8Uyz8j+kQwcLqOM/goRANwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAyfkAcHTIywLKB8v/ydDPFpZsInABywHi9AALADQzUDXHBfLgSQP6QDBZyFAE+gJYzxbMzMntVABCjhhRJMcF8uBJ1DBDAMhQBPoCWM8WzMzJ7VTgXwWED/LwAArJgED7AAB9rbz2omh9AH0gamoYNhj8FAC4KhAJqgoB5CgCfQEsZ4sA54tmZJFkZYCJegB6AGWAZPyAODpkZYFlA+X/5OhAAB+vFvaiaH0AfSBqahg/qpBA"
    };
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonMintMessage.js
var require_JettonMintMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonMintMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonMintMessage = exports.storeJettonMintMessage = void 0;
    var core_1 = require_dist2();
    var opcodes_1 = require_opcodes();
    var JettonInternalTransferMessage_1 = require_JettonInternalTransferMessage();
    function storeJettonMintMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.JETTON_MINT_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeAddress(src.to);
        builder.storeCoins(src.walletForwardValue);
        builder.storeRef((0, core_1.beginCell)().store((0, JettonInternalTransferMessage_1.storeJettonInternalTransferMessage)(src)).endCell());
      };
    }
    exports.storeJettonMintMessage = storeJettonMintMessage;
    function loadJettonMintMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.JETTON_MINT_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const to = slice.loadAddress();
      const walletForwardValue = slice.loadCoins();
      const internalTransfer = (0, JettonInternalTransferMessage_1.loadJettonInternalTransferMessage)(slice.loadRef().beginParse());
      return {
        queryId,
        amount: internalTransfer.amount,
        from: internalTransfer.from,
        to,
        responseAddress: internalTransfer.responseAddress,
        forwardTonAmount: internalTransfer.forwardTonAmount,
        forwardPayload: internalTransfer.forwardPayload,
        walletForwardValue
      };
    }
    exports.loadJettonMintMessage = loadJettonMintMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonMinterContent.js
var require_JettonMinterContent = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonMinterContent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonMinterContent = exports.storeJettonMinterContent = void 0;
    function storeJettonMinterContent(src) {
      return (builder) => {
        builder.storeCoins(0);
        builder.storeAddress(src.admin);
        builder.storeRef(src.content);
        builder.storeRef(src.jettonWalletCode);
      };
    }
    exports.storeJettonMinterContent = storeJettonMinterContent;
    function loadJettonMinterContent(slice) {
      const totalSupply = slice.loadCoins();
      const adminAddress = slice.loadAddress();
      const jettonContent = slice.loadRef();
      const jettonWalletCode = slice.loadRef();
      return {
        admin: adminAddress,
        content: jettonContent,
        jettonWalletCode
      };
    }
    exports.loadJettonMinterContent = loadJettonMinterContent;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonChangeAdminMessage.js
var require_JettonChangeAdminMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonChangeAdminMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonChangeAdminMessage = exports.storeJettonChangeAdminMessage = void 0;
    var opcodes_1 = require_opcodes();
    function storeJettonChangeAdminMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.JETTON_CHANGE_ADMIN_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeAddress(src.newAdmin);
      };
    }
    exports.storeJettonChangeAdminMessage = storeJettonChangeAdminMessage;
    function loadJettonChangeAdminMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.JETTON_CHANGE_ADMIN_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const newAdmin = slice.loadAddress();
      return {
        queryId,
        newAdmin
      };
    }
    exports.loadJettonChangeAdminMessage = loadJettonChangeAdminMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonChangeContentMessage.js
var require_JettonChangeContentMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonChangeContentMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonChangeContentMessage = exports.storeJettonChangeContentMessage = void 0;
    var opcodes_1 = require_opcodes();
    function storeJettonChangeContentMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.JETTON_CHANGE_CONTENT_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeRef(src.newContent);
      };
    }
    exports.storeJettonChangeContentMessage = storeJettonChangeContentMessage;
    function loadJettonChangeContentMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.JETTON_CHANGE_CONTENT_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const newContent = slice.loadRef();
      return {
        queryId,
        newContent
      };
    }
    exports.loadJettonChangeContentMessage = loadJettonChangeContentMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonMinterMessage.js
var require_JettonMinterMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonMinterMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonMinterMessage = void 0;
    var JettonMintMessage_1 = require_JettonMintMessage();
    var JettonInternalTransferMessage_1 = require_JettonInternalTransferMessage();
    var JettonChangeAdminMessage_1 = require_JettonChangeAdminMessage();
    var JettonChangeContentMessage_1 = require_JettonChangeContentMessage();
    var opcodes_1 = require_opcodes();
    function loadJettonMinterMessage(slice) {
      try {
        const opcode = slice.preloadUint(32);
        switch (opcode) {
          case opcodes_1.JETTON_MINT_OPCODE:
            return { kind: "mint", ...(0, JettonMintMessage_1.loadJettonMintMessage)(slice) };
          case opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE:
            return { kind: "internal_transfer", ...(0, JettonInternalTransferMessage_1.loadJettonInternalTransferMessage)(slice) };
          case opcodes_1.JETTON_CHANGE_ADMIN_OPCODE:
            return { kind: "change_admin", ...(0, JettonChangeAdminMessage_1.loadJettonChangeAdminMessage)(slice) };
          case opcodes_1.JETTON_CHANGE_CONTENT_OPCODE:
            return { kind: "change_content", ...(0, JettonChangeContentMessage_1.loadJettonChangeContentMessage)(slice) };
        }
      } catch (e) {
      }
      return { kind: "unknown" };
    }
    exports.loadJettonMinterMessage = loadJettonMinterMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonMinterAction.js
var require_JettonMinterAction = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonMinterAction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJettonMinterTransaction = void 0;
    var JettonMinterMessage_1 = require_JettonMinterMessage();
    var TransferAction_1 = require_TransferAction();
    function parseJettonMinterTransaction(tx) {
      const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
      if (mayBeTransfer.kind !== "unknown") {
        return mayBeTransfer;
      }
      if (tx.description.type !== "generic") {
        return { kind: "unknown", transaction: tx };
      }
      if (!tx.inMessage) {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.inMessage.info.type !== "internal") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.type !== "vm") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.exitCode !== 0) {
        return { kind: "unknown", transaction: tx };
      }
      const inMessage = (0, JettonMinterMessage_1.loadJettonMinterMessage)(tx.inMessage.body.beginParse());
      if (inMessage.kind === "mint") {
        return {
          kind: "mint",
          queryId: inMessage.queryId,
          amount: inMessage.amount,
          recipient: inMessage.to,
          responseAddress: inMessage.responseAddress,
          forwardPayload: inMessage.forwardPayload,
          forwardTonAmount: inMessage.forwardTonAmount,
          value: tx.inMessage.info.value.coins,
          transaction: tx
        };
      }
      if (inMessage.kind === "internal_transfer") {
        return {
          kind: "burn",
          queryId: inMessage.queryId,
          amount: inMessage.amount,
          from: inMessage.from,
          value: tx.inMessage.info.value.coins,
          transaction: tx
        };
      }
      if (inMessage.kind === "change_admin") {
        return {
          kind: "change_admin",
          queryId: inMessage.queryId,
          newAdmin: inMessage.newAdmin,
          value: tx.inMessage.info.value.coins,
          transaction: tx
        };
      }
      if (inMessage.kind === "change_content") {
        return {
          kind: "change_content",
          queryId: inMessage.queryId,
          newContent: inMessage.newContent,
          value: tx.inMessage.info.value.coins,
          transaction: tx
        };
      }
      return { kind: "unknown", transaction: tx };
    }
    exports.parseJettonMinterTransaction = parseJettonMinterTransaction;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/JettonMinter.js
var require_JettonMinter = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/JettonMinter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JettonMinter = exports.jettonMinterConfigToCell = void 0;
    var core_1 = require_dist2();
    var JettonWallet_1 = require_JettonWallet();
    var content_1 = require_content();
    var content_2 = require_content2();
    var jetton_minter_1 = require_jetton_minter();
    var types_1 = require_types();
    var JettonMintMessage_1 = require_JettonMintMessage();
    var JettonMinterContent_1 = require_JettonMinterContent();
    var JettonChangeAdminMessage_1 = require_JettonChangeAdminMessage();
    var JettonChangeContentMessage_1 = require_JettonChangeContentMessage();
    var JettonMinterAction_1 = require_JettonMinterAction();
    function jettonMinterConfigToCell(config) {
      return (0, core_1.beginCell)().store((0, JettonMinterContent_1.storeJettonMinterContent)({
        admin: config.admin,
        content: config.content,
        jettonWalletCode: config.jettonWalletCode ?? JettonWallet_1.JettonWallet.code
      })).endCell();
    }
    exports.jettonMinterConfigToCell = jettonMinterConfigToCell;
    var JettonMinter = class _JettonMinter {
      constructor(address, init, contentResolver) {
        this.address = address;
        this.init = init;
        this.contentResolver = contentResolver;
      }
      static createFromAddress(address, contentResolver) {
        return new _JettonMinter(address, void 0, contentResolver);
      }
      static createFromConfig(config, code, workchain, contentResolver) {
        const data = jettonMinterConfigToCell(config);
        const init = { data, code: code ?? _JettonMinter.code };
        return new _JettonMinter((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
      }
      async sendDeploy(provider, sender, value) {
        await provider.internal(sender, {
          value: value ?? (0, core_1.toNano)("0.05"),
          bounce: true
        });
      }
      async sendMint(provider, sender, recipient, amount, options) {
        const notification = (0, types_1.parseNotifyOptions)(options == null ? void 0 : options.notify);
        const excessReturn = (0, types_1.parseExcessReturnOptions)(options == null ? void 0 : options.returnExcess, sender);
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          body: (0, core_1.beginCell)().store((0, JettonMintMessage_1.storeJettonMintMessage)({
            queryId: (options == null ? void 0 : options.queryId) ?? 0n,
            amount,
            from: this.address,
            to: recipient,
            responseAddress: (excessReturn == null ? void 0 : excessReturn.address) ?? null,
            forwardPayload: (notification == null ? void 0 : notification.payload) ?? null,
            forwardTonAmount: (notification == null ? void 0 : notification.amount) ?? 0n,
            walletForwardValue: ((notification == null ? void 0 : notification.amount) ?? 0n) + (excessReturn ? (0, core_1.toNano)("0.01") : 0n) + (0, core_1.toNano)(0.02)
          })).endCell()
        });
      }
      async sendChangeAdmin(provider, sender, newAdmin, options) {
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          body: (0, core_1.beginCell)().store((0, JettonChangeAdminMessage_1.storeJettonChangeAdminMessage)({
            queryId: (options == null ? void 0 : options.queryId) ?? 0n,
            newAdmin
          })).endCell()
        });
      }
      async sendChangeContent(provider, sender, newContent, options) {
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          body: (0, core_1.beginCell)().store((0, JettonChangeContentMessage_1.storeJettonChangeContentMessage)({
            queryId: (options == null ? void 0 : options.queryId) ?? 0n,
            newContent
          })).endCell()
        });
      }
      async getData(provider) {
        const builder = new core_1.TupleBuilder();
        const { stack } = await provider.get("get_jetton_data", builder.build());
        return {
          totalSupply: stack.readBigNumber(),
          mintable: stack.readBigNumber() !== 0n,
          adminAddress: stack.readAddressOpt(),
          jettonContent: stack.readCell(),
          jettonWalletCode: stack.readCell()
        };
      }
      async getWalletAddress(provider, owner) {
        const builder = new core_1.TupleBuilder();
        builder.writeAddress(owner);
        const { stack } = await provider.get("get_wallet_address", builder.build());
        return stack.readAddress();
      }
      async getWallet(provider, owner) {
        const jettonWalletAddress = await this.getWalletAddress(provider, owner);
        return provider.open(new JettonWallet_1.JettonWallet(jettonWalletAddress));
      }
      async getContent(provider) {
        if (!this.contentResolver) {
          throw new Error("No content resolver");
        }
        const data = await this.getData(provider);
        return (0, content_2.parseJettonContent)(await (0, content_1.loadFullContent)(data.jettonContent, this.contentResolver));
      }
      async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
          const state = await provider.getState();
          if (!state.last) {
            return [];
          }
          lt = state.last.lt;
          hash = state.last.hash;
        }
        const transactions = await provider.getTransactions(this.address, lt, hash, limit);
        return transactions.map((tx) => (0, JettonMinterAction_1.parseJettonMinterTransaction)(tx));
      }
    };
    exports.JettonMinter = JettonMinter;
    JettonMinter.code = core_1.Cell.fromBase64(jetton_minter_1.jettonMinterCode.codeBoc);
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/contracts/build/nft-collection-editable.js
var require_nft_collection_editable = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/contracts/build/nft-collection-editable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nftCollectionEditableCode = void 0;
    exports.nftCollectionEditableCode = {
      codeBoc: "te6ccgECFAEAAh8AART/APSkE/S88sgLAQIBYgIDAgLNBAUCASAODwTn0QY4BIrfAA6GmBgLjYSK3wfSAYAOmP6Z/2omh9IGmf6mpqGEEINJ6cqClAXUcUG6+CgOhBCFRlgFa4QAhkZYKoAueLEn0BCmW1CeWP5Z+A54tkwCB9gHAbKLnjgvlwyJLgAPGBEuABcYES4AHxgRgZgeACQGBwgJAgEgCgsAYDUC0z9TE7vy4ZJTE7oB+gDUMCgQNFnwBo4SAaRDQ8hQBc8WE8s/zMzMye1Ukl8F4gCmNXAD1DCON4BA9JZvpSCOKQakIIEA+r6T8sGP3oEBkyGgUyW78vQC+gDUMCJUSzDwBiO6kwKkAt4Ekmwh4rPmMDJQREMTyFAFzxYTyz/MzMzJ7VQALDI0AfpAMEFEyFAFzxYTyz/MzMzJ7VQAPI4V1NQwEDRBMMhQBc8WE8s/zMzMye1U4F8EhA/y8AIBIAwNAD1FrwBHAh8AV3gBjIywVYzxZQBPoCE8trEszMyXH7AIAC0AcjLP/gozxbJcCDIywET9AD0AMsAyYAAbPkAdMjLAhLKB8v/ydCACASAQEQAlvILfaiaH0gaZ/qamoYLehqGCxABDuLXTHtRND6QNM/1NTUMBAkXwTQ1DHUMNBxyMsHAc8WzMmAIBIBITAC+12v2omh9IGmf6mpqGDYg6GmH6Yf9IBhAALbT0faiaH0gaZ/qamoYCi+CeAI4APgCw"
    };
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftRoyaltyParams.js
var require_NftRoyaltyParams = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftRoyaltyParams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftRoyaltyParams = exports.storeNftRoyaltyParams = void 0;
    function storeNftRoyaltyParams(src) {
      return (builder) => {
        builder.storeUint(src.numerator, 16);
        builder.storeUint(src.denominator, 16);
        builder.storeAddress(src.recipient);
      };
    }
    exports.storeNftRoyaltyParams = storeNftRoyaltyParams;
    function loadNftRoyaltyParams(slice) {
      return {
        numerator: slice.loadUintBig(16),
        denominator: slice.loadUintBig(16),
        recipient: slice.loadAddress()
      };
    }
    exports.loadNftRoyaltyParams = loadNftRoyaltyParams;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/opcodes.js
var require_opcodes2 = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/opcodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NFT_EXCESSES_OPCODE = exports.NFT_REPORT_STATIC_DATA_OPCODE = exports.NFT_GET_STATIC_DATA_OPCODE = exports.NFT_OWNER_ASSIGNED_OPCODE = exports.NFT_TRANSFER_OPCODE = exports.NFT_CHANGE_CONTENT_OPCODE = exports.NFT_CHANGE_ADMIN_OPCODE = exports.NFT_BATCH_MINT_OPCODE = exports.NFT_MINT_OPCODE = void 0;
    exports.NFT_MINT_OPCODE = 1;
    exports.NFT_BATCH_MINT_OPCODE = 2;
    exports.NFT_CHANGE_ADMIN_OPCODE = 3;
    exports.NFT_CHANGE_CONTENT_OPCODE = 4;
    exports.NFT_TRANSFER_OPCODE = 1607220500;
    exports.NFT_OWNER_ASSIGNED_OPCODE = 85167505;
    exports.NFT_GET_STATIC_DATA_OPCODE = 801842850;
    exports.NFT_REPORT_STATIC_DATA_OPCODE = 2339837749;
    exports.NFT_EXCESSES_OPCODE = 3576854235;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftChangeContentMessage.js
var require_NftChangeContentMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftChangeContentMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftChangeContentMessage = exports.storeNftChangeContentMessage = void 0;
    var NftRoyaltyParams_1 = require_NftRoyaltyParams();
    var opcodes_1 = require_opcodes2();
    function storeNftChangeContentMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.NFT_CHANGE_CONTENT_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeRef(src.newContent);
        builder.store((0, NftRoyaltyParams_1.storeNftRoyaltyParams)(src.newRoyaltyParams));
      };
    }
    exports.storeNftChangeContentMessage = storeNftChangeContentMessage;
    function loadNftChangeContentMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.NFT_CHANGE_CONTENT_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const newContent = slice.loadRef();
      const newRoyaltyParams = (0, NftRoyaltyParams_1.loadNftRoyaltyParams)(slice.loadRef().beginParse());
      return {
        queryId,
        newContent,
        newRoyaltyParams
      };
    }
    exports.loadNftChangeContentMessage = loadNftChangeContentMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftMintMessage.js
var require_NftMintMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftMintMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftMintMessage = exports.storeNftMintMessage = void 0;
    var core_1 = require_dist2();
    var opcodes_1 = require_opcodes2();
    function storeNftMintMessage(src, storeParams) {
      return (builder) => {
        builder.storeUint(opcodes_1.NFT_MINT_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
        builder.storeUint(src.itemIndex, 64);
        builder.storeCoins(src.value);
        builder.storeRef((0, core_1.beginCell)().store(storeParams(src.itemParams)).endCell());
      };
    }
    exports.storeNftMintMessage = storeNftMintMessage;
    function loadNftMintMessage(slice, loadParams) {
      if (slice.loadUint(32) !== opcodes_1.NFT_MINT_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const itemIndex = slice.loadUintBig(64);
      const value = slice.loadCoins();
      const itemParams = slice.loadRef();
      return {
        itemIndex,
        value,
        itemParams: loadParams(itemParams.beginParse()),
        queryId
      };
    }
    exports.loadNftMintMessage = loadNftMintMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftBatchMintMessage.js
var require_NftBatchMintMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftBatchMintMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNftMintItemValue = exports.loadNftBatchMintItem = exports.storeNftBatchMintItem = exports.loadNftBatchMintMessage = exports.storeNftBatchMintMessage = void 0;
    var core_1 = require_dist2();
    var opcodes_1 = require_opcodes2();
    function storeNftBatchMintMessage(src, storeParams) {
      return (builder) => {
        const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.BigUint(64), createNftMintItemValue(storeParams));
        for (const r of src.requests) {
          if (dict.has(r.index)) {
            throw new Error("Duplicate items");
          }
          dict.set(r.index, r);
        }
        builder.storeUint(opcodes_1.NFT_BATCH_MINT_OPCODE, 32);
        builder.storeUint(src.queryId ?? 0, 64);
        builder.storeRef((0, core_1.beginCell)().storeDictDirect(dict));
      };
    }
    exports.storeNftBatchMintMessage = storeNftBatchMintMessage;
    function loadNftBatchMintMessage(slice, loadParams) {
      if (slice.loadUint(32) !== opcodes_1.NFT_BATCH_MINT_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const requests = slice.loadDictDirect(core_1.Dictionary.Keys.BigUint(64), createNftMintItemValue(void 0, loadParams));
      return {
        queryId,
        requests: requests.values()
      };
    }
    exports.loadNftBatchMintMessage = loadNftBatchMintMessage;
    function storeNftBatchMintItem(request, storeParams) {
      return (builder) => {
        builder.storeCoins(request.value ?? (0, core_1.toNano)("0.03"));
        builder.storeRef((0, core_1.beginCell)().store(storeParams(request.params)).endCell());
      };
    }
    exports.storeNftBatchMintItem = storeNftBatchMintItem;
    function loadNftBatchMintItem(slice, loadParams) {
      const itemIndex = slice.loadUintBig(64);
      const value = slice.loadCoins();
      const params = slice.loadRef();
      return {
        index: itemIndex,
        value,
        params: loadParams(params.beginParse())
      };
    }
    exports.loadNftBatchMintItem = loadNftBatchMintItem;
    function createNftMintItemValue(storeParams, loadParams) {
      return {
        serialize(src, builder) {
          if (!storeParams) {
            throw new Error("storeParams is not defined");
          }
          builder.store(storeNftBatchMintItem(src, storeParams));
        },
        parse(src) {
          if (!loadParams) {
            throw new Error("loadParams is not defined");
          }
          return loadNftBatchMintItem(src, loadParams);
        }
      };
    }
    exports.createNftMintItemValue = createNftMintItemValue;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftChangeAdminMessage.js
var require_NftChangeAdminMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftChangeAdminMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftChangeAdminMessage = exports.storeNftChangeAdminMessage = void 0;
    var opcodes_1 = require_opcodes2();
    function storeNftChangeAdminMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.NFT_CHANGE_ADMIN_OPCODE, 32);
        builder.storeUint(src.queryId ?? 0, 64);
        builder.storeAddress(src.newAdmin);
      };
    }
    exports.storeNftChangeAdminMessage = storeNftChangeAdminMessage;
    function loadNftChangeAdminMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.NFT_CHANGE_ADMIN_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const newAdmin = slice.loadAddress();
      return {
        queryId,
        newAdmin
      };
    }
    exports.loadNftChangeAdminMessage = loadNftChangeAdminMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/NftCollectionBase.js
var require_NftCollectionBase = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/NftCollectionBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NftCollectionBase = void 0;
    var core_1 = require_dist2();
    var content_1 = require_content();
    var content_2 = require_content3();
    var nft_collection_editable_1 = require_nft_collection_editable();
    var NftChangeContentMessage_1 = require_NftChangeContentMessage();
    var NftMintMessage_1 = require_NftMintMessage();
    var NftBatchMintMessage_1 = require_NftBatchMintMessage();
    var NftChangeAdminMessage_1 = require_NftChangeAdminMessage();
    var NftCollectionBase = class {
      constructor(address, init, contentResolver, nftItemParamsValue) {
        this.address = address;
        this.init = init;
        this.contentResolver = contentResolver;
        this.itemParamsValue = nftItemParamsValue;
      }
      async sendDeploy(provider, sender, value) {
        await provider.internal(sender, {
          value: value ?? (0, core_1.toNano)("0.05"),
          bounce: true
        });
      }
      async sendMint(provider, sender, item, options) {
        if (this.itemParamsValue === void 0) {
          throw new Error("No item params value");
        }
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
          body: (0, core_1.beginCell)().store((0, NftMintMessage_1.storeNftMintMessage)({
            queryId: (options == null ? void 0 : options.queryId) ?? 0n,
            itemIndex: item.index,
            itemParams: item,
            value: item.value ?? (0, core_1.toNano)("0.03")
          }, this.itemParamsValue.store)).endCell()
        });
      }
      async sendBatchMint(provider, sender, items, options) {
        if (this.itemParamsValue === void 0) {
          throw new Error("No item params value");
        }
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05") * BigInt(items.length),
          bounce: true,
          body: (0, core_1.beginCell)().store((0, NftBatchMintMessage_1.storeNftBatchMintMessage)({
            queryId: (options == null ? void 0 : options.queryId) ?? 0n,
            requests: items.map((item) => ({
              index: item.index,
              params: item,
              value: item.value ?? (0, core_1.toNano)("0.03")
            }))
          }, this.itemParamsValue.store)).endCell()
        });
      }
      async sendChangeAdmin(provider, sender, newAdmin, options) {
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          body: (0, core_1.beginCell)().store((0, NftChangeAdminMessage_1.storeNftChangeAdminMessage)({
            newAdmin,
            queryId: (options == null ? void 0 : options.queryId) ?? 0n
          })).endCell()
        });
      }
      async sendChangeContent(provider, sender, message, options) {
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          body: (0, core_1.beginCell)().store((0, NftChangeContentMessage_1.storeNftChangeContentMessage)({
            queryId: (options == null ? void 0 : options.queryId) ?? 0n,
            newContent: message.newContent,
            newRoyaltyParams: message.newRoyaltyParams
          })).endCell()
        });
      }
      async getItemAddress(provider, index) {
        const ret = await provider.get("get_nft_address_by_index", [{ type: "int", value: index }]);
        return ret.stack.readAddress();
      }
      async getData(provider) {
        const ret = await provider.get("get_collection_data", []);
        return {
          nextItemIndex: ret.stack.readBigNumber(),
          content: ret.stack.readCell(),
          owner: ret.stack.readAddressOpt()
        };
      }
      async getContent(provider) {
        if (this.contentResolver === void 0) {
          throw new Error("No content resolver");
        }
        const data = await this.getData(provider);
        return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(data.content, this.contentResolver));
      }
      async getItemContent(provider, index, individualContent) {
        const res = await provider.get("get_nft_content", [{
          type: "int",
          value: index
        }, {
          type: "cell",
          cell: individualContent
        }]);
        return res.stack.readCell();
      }
    };
    exports.NftCollectionBase = NftCollectionBase;
    NftCollectionBase.code = core_1.Cell.fromBase64(nft_collection_editable_1.nftCollectionEditableCode.codeBoc);
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/contracts/build/nft-item.js
var require_nft_item = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/contracts/build/nft-item.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nftItemCode = void 0;
    exports.nftItemCode = {
      codeBoc: "te6ccgECDgEAAdwAART/APSkE/S88sgLAQIBYgIDAgLOBAUACaEfn+AFAgEgBgcCASAMDQLPDIhxwCSXwPg0NMDAXGwkl8D4PpA+kAx+gAxcdch+gAx+gAwc6m0APACBLOOFDBsIjRSMscF8uGVAfpA1DAQI/AD4AbTH9M/ghBfzD0UUjC64wIwNDQ1NYIQL8smohK64wJfBIQP8vCAICQARPpEMHC68uFNgAqwyEDdeMkATUTXHBfLhkfpAIfAB+kDSADH6ACDXScIA8uLEggr68IAboSGUUxWgod4i1wsBwwAgkgahkTbiIML/8uGSIZQQKjdb4w0CkzAyNOMNVQLwAwoLAHJwghCLdxc1BcjL/1AEzxYQJIBAcIAQyMsFUAfPFlAF+gIVy2oSyx/LPyJus5RYzxcBkTLiAckB+wAAfIIQBRONkchQCc8WUAvPFnEkSRRURqBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7ABBHAGom8AGCENUydtsQN0QAbXFwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AAA7O1E0NM/+kAg10nCAJp/AfpA1DAQJBAj4DBwWW1tgAB0A8jLP1jPFgHPFszJ7VSA="
    };
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftItemParams.js
var require_NftItemParams = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftItemParams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNftItemParamsValue = exports.loadNftItemParams = exports.storeNftItemParams = void 0;
    var core_1 = require_dist2();
    function storeNftItemParams(src) {
      return (builder) => {
        builder.storeAddress(src.owner);
        if (typeof src.individualContent === "string") {
          builder.storeRef((0, core_1.beginCell)().storeStringTail(src.individualContent).endCell());
        } else {
          builder.storeRef(src.individualContent);
        }
      };
    }
    exports.storeNftItemParams = storeNftItemParams;
    function loadNftItemParams(slice) {
      return {
        owner: slice.loadAddress(),
        individualContent: slice.loadRef()
      };
    }
    exports.loadNftItemParams = loadNftItemParams;
    function createNftItemParamsValue() {
      return {
        store: storeNftItemParams,
        load: loadNftItemParams
      };
    }
    exports.createNftItemParamsValue = createNftItemParamsValue;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftTransferMessage.js
var require_NftTransferMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftTransferMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftTransferMessage = exports.storeNftTransferMessage = void 0;
    var opcodes_1 = require_opcodes2();
    function storeNftTransferMessage(message) {
      return (builder) => {
        const { queryId, newOwner, responseDestination, customPayload, forwardAmount, forwardPayload } = message;
        builder.storeUint(opcodes_1.NFT_TRANSFER_OPCODE, 32).storeUint(queryId, 64).storeAddress(newOwner).storeAddress(responseDestination).storeMaybeRef(customPayload).storeCoins(forwardAmount).storeMaybeRef(forwardPayload);
      };
    }
    exports.storeNftTransferMessage = storeNftTransferMessage;
    function loadNftTransferMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.NFT_TRANSFER_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const newOwner = slice.loadAddress();
      const responseDestination = slice.loadMaybeAddress();
      const customPayload = slice.loadMaybeRef();
      const forwardAmount = slice.loadCoins();
      const eitherPayload = slice.loadBoolean();
      const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
      return {
        queryId,
        newOwner,
        responseDestination,
        customPayload,
        forwardAmount,
        forwardPayload
      };
    }
    exports.loadNftTransferMessage = loadNftTransferMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftDeployMessage.js
var require_NftDeployMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftDeployMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftDeployMessage = exports.storeNftDeployMessage = void 0;
    function storeNftDeployMessage(message) {
      return (builder) => {
        const { owner, content } = message;
        builder.storeAddress(owner).storeRef(content);
      };
    }
    exports.storeNftDeployMessage = storeNftDeployMessage;
    function loadNftDeployMessage(slice) {
      const owner = slice.loadAddress();
      const content = slice.loadRef();
      return {
        owner,
        content
      };
    }
    exports.loadNftDeployMessage = loadNftDeployMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftGetStaticDataMessage.js
var require_NftGetStaticDataMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftGetStaticDataMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftGetStaticDataMessage = exports.storeNftGetStaticDataMessage = void 0;
    var opcodes_1 = require_opcodes2();
    function storeNftGetStaticDataMessage(message) {
      return (builder) => {
        const { queryId } = message;
        builder.storeUint(opcodes_1.NFT_GET_STATIC_DATA_OPCODE, 32).storeUint(queryId, 64);
      };
    }
    exports.storeNftGetStaticDataMessage = storeNftGetStaticDataMessage;
    function loadNftGetStaticDataMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.NFT_GET_STATIC_DATA_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      return {
        queryId
      };
    }
    exports.loadNftGetStaticDataMessage = loadNftGetStaticDataMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftReportStaticDataMessage.js
var require_NftReportStaticDataMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftReportStaticDataMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftReportStaticDataMessage = exports.storeNftReportStaticDataMessage = void 0;
    var opcodes_1 = require_opcodes2();
    function storeNftReportStaticDataMessage(message) {
      return (builder) => {
        const { queryId, index, collection } = message;
        builder.storeUint(opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE, 32).storeUint(queryId, 64).storeUint(index, 256).storeAddress(collection);
      };
    }
    exports.storeNftReportStaticDataMessage = storeNftReportStaticDataMessage;
    function loadNftReportStaticDataMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const index = slice.loadUintBig(256);
      const collection = slice.loadAddress();
      return {
        queryId,
        index,
        collection
      };
    }
    exports.loadNftReportStaticDataMessage = loadNftReportStaticDataMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftOwnerAssignedMessage.js
var require_NftOwnerAssignedMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftOwnerAssignedMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftOwnerAssignedMessage = exports.storeNftOwnerAssignedMessage = void 0;
    var opcodes_1 = require_opcodes2();
    function storeNftOwnerAssignedMessage(message) {
      return (builder) => {
        const { queryId, previousOwner, payload } = message;
        builder.storeUint(opcodes_1.NFT_OWNER_ASSIGNED_OPCODE, 32).storeUint(queryId, 64).storeAddress(previousOwner).storeMaybeRef(payload);
      };
    }
    exports.storeNftOwnerAssignedMessage = storeNftOwnerAssignedMessage;
    function loadNftOwnerAssignedMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.NFT_OWNER_ASSIGNED_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      const previousOwner = slice.loadAddress();
      const eitherPayload = slice.loadBoolean();
      const payload = eitherPayload ? slice.loadRef() : slice.asCell();
      return {
        queryId,
        previousOwner,
        payload
      };
    }
    exports.loadNftOwnerAssignedMessage = loadNftOwnerAssignedMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftExcessesMessage.js
var require_NftExcessesMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftExcessesMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftExcessesMessage = exports.storeNftExcessesMessage = void 0;
    var opcodes_1 = require_opcodes2();
    function storeNftExcessesMessage(message) {
      return (builder) => {
        const { queryId } = message;
        builder.storeUint(opcodes_1.NFT_EXCESSES_OPCODE, 32).storeUint(queryId, 64);
      };
    }
    exports.storeNftExcessesMessage = storeNftExcessesMessage;
    function loadNftExcessesMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.NFT_EXCESSES_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const queryId = slice.loadUintBig(64);
      return {
        queryId
      };
    }
    exports.loadNftExcessesMessage = loadNftExcessesMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftMessage.js
var require_NftMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftMessage = void 0;
    var NftDeployMessage_1 = require_NftDeployMessage();
    var NftTransferMessage_1 = require_NftTransferMessage();
    var NftGetStaticDataMessage_1 = require_NftGetStaticDataMessage();
    var NftReportStaticDataMessage_1 = require_NftReportStaticDataMessage();
    var NftOwnerAssignedMessage_1 = require_NftOwnerAssignedMessage();
    var opcodes_1 = require_opcodes2();
    var NftExcessesMessage_1 = require_NftExcessesMessage();
    function loadNftMessage(slice) {
      try {
        const opcode = slice.preloadUint(32);
        switch (opcode) {
          case opcodes_1.NFT_TRANSFER_OPCODE:
            return { kind: "nft_transfer", ...(0, NftTransferMessage_1.loadNftTransferMessage)(slice) };
          case opcodes_1.NFT_OWNER_ASSIGNED_OPCODE:
            return { kind: "owner_assigned", ...(0, NftOwnerAssignedMessage_1.loadNftOwnerAssignedMessage)(slice) };
          case opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE:
            return { kind: "report_static_data", ...(0, NftReportStaticDataMessage_1.loadNftReportStaticDataMessage)(slice) };
          case opcodes_1.NFT_GET_STATIC_DATA_OPCODE:
            return { kind: "get_static_data", ...(0, NftGetStaticDataMessage_1.loadNftGetStaticDataMessage)(slice) };
          case opcodes_1.NFT_EXCESSES_OPCODE:
            return { kind: "excesses", ...(0, NftExcessesMessage_1.loadNftExcessesMessage)(slice) };
        }
        if (slice.remainingBits === 256 + 11 && slice.remainingRefs === 1) {
          return { kind: "nft_deploy", ...(0, NftDeployMessage_1.loadNftDeployMessage)(slice) };
        }
      } catch (e) {
      }
      return { kind: "unknown" };
    }
    exports.loadNftMessage = loadNftMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftItemAction.js
var require_NftItemAction = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftItemAction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseNftItemTransaction = void 0;
    var NftMessage_1 = require_NftMessage();
    var TransferAction_1 = require_TransferAction();
    function parseNftItemTransaction(tx) {
      const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
      if (mayBeTransfer.kind !== "unknown") {
        return mayBeTransfer;
      }
      if (tx.description.type !== "generic") {
        return { kind: "unknown", transaction: tx };
      }
      if (!tx.inMessage) {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.inMessage.info.type !== "internal") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.type !== "vm") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.exitCode !== 0) {
        return { kind: "unknown", transaction: tx };
      }
      const inMessage = (0, NftMessage_1.loadNftMessage)(tx.inMessage.body.beginParse());
      if (inMessage.kind === "nft_deploy") {
        return {
          kind: "deploy",
          owner: inMessage.owner,
          content: inMessage.content,
          collection: tx.inMessage.info.src,
          transaction: tx
        };
      }
      if (inMessage.kind === "nft_transfer") {
        return {
          kind: "nft_transfer",
          queryId: inMessage.queryId,
          newOwner: inMessage.newOwner,
          customPayload: inMessage.customPayload ?? null,
          forwardAmount: inMessage.forwardAmount,
          forwardPayload: inMessage.forwardPayload ?? null,
          transaction: tx
        };
      }
      return { kind: "unknown", transaction: tx };
    }
    exports.parseNftItemTransaction = parseNftItemTransaction;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/NftItem.js
var require_NftItem = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/NftItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NftItem = exports.nftItemConfigToCell = void 0;
    var core_1 = require_dist2();
    var content_1 = require_content();
    var NftCollection_1 = require_NftCollection();
    var content_2 = require_content3();
    var nft_item_1 = require_nft_item();
    var types_1 = require_types();
    var NftItemParams_1 = require_NftItemParams();
    var NftTransferMessage_1 = require_NftTransferMessage();
    var NftItemAction_1 = require_NftItemAction();
    function nftItemConfigToCell(config) {
      return (0, core_1.beginCell)().storeUint(config.index, 64).storeAddress(config.collection).endCell();
    }
    exports.nftItemConfigToCell = nftItemConfigToCell;
    var NftItem = class _NftItem {
      constructor(address, init, contentResolver) {
        this.address = address;
        this.init = init;
        this.contentResolver = contentResolver;
      }
      static createFromConfig(config, code, workchain, contentResolver) {
        const data = nftItemConfigToCell(config);
        const init = { data, code: code ?? _NftItem.nftCode };
        return new _NftItem((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
      }
      static createFromAddress(address, contentResolver) {
        return new _NftItem(address, void 0, contentResolver);
      }
      async sendDeploy(provider, sender, params, value) {
        await provider.internal(sender, {
          value: value ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          body: (0, core_1.beginCell)().store((0, NftItemParams_1.storeNftItemParams)(params)).endCell()
        });
      }
      async send(provider, sender, newOwner, options) {
        const notification = (0, types_1.parseNotifyOptions)(options == null ? void 0 : options.notify);
        const excessReturn = (0, types_1.parseExcessReturnOptions)(options == null ? void 0 : options.returnExcess, sender);
        await provider.internal(sender, {
          value: ((options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05")) + ((notification == null ? void 0 : notification.amount) ?? 0n),
          bounce: true,
          sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
          body: (0, core_1.beginCell)().store((0, NftTransferMessage_1.storeNftTransferMessage)({
            queryId: (options == null ? void 0 : options.queryId) ?? 0n,
            newOwner,
            responseDestination: (excessReturn == null ? void 0 : excessReturn.address) ?? null,
            customPayload: (options == null ? void 0 : options.customPayload) ?? null,
            forwardAmount: (notification == null ? void 0 : notification.amount) ?? 0n,
            forwardPayload: (notification == null ? void 0 : notification.payload) ?? null
          })).endCell()
        });
      }
      async getData(provider) {
        const { stack } = await provider.get("get_nft_data", []);
        return {
          initialized: stack.readBoolean(),
          index: stack.readBigNumber(),
          collection: stack.readAddressOpt(),
          owner: stack.readAddressOpt(),
          individualContent: stack.readCellOpt()
        };
      }
      async getContent(provider) {
        if (this.contentResolver === void 0) {
          throw new Error("No content resolver");
        }
        const { collection, individualContent, index } = await this.getData(provider);
        if (individualContent === null) {
          throw new Error("Individual content is null");
        }
        let content;
        if (collection === null) {
          content = individualContent;
        } else {
          const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
          content = await collectionContract.getItemContent(index, individualContent);
        }
        return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(content, this.contentResolver));
      }
      async getRoyaltyParams(provider) {
        const { collection } = await this.getData(provider);
        if (collection === null) {
          return this.getNftItemRoyaltyParams(provider);
        }
        const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
        return collectionContract.getRoyaltyParams();
      }
      async getNftItemRoyaltyParams(provider) {
        const { stack } = await provider.get("get_royalty_params", []);
        return {
          numerator: stack.readBigNumber(),
          denominator: stack.readBigNumber(),
          recipient: stack.readAddress()
        };
      }
      async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
          const state = await provider.getState();
          if (!state.last) {
            return [];
          }
          lt = state.last.lt;
          hash = state.last.hash;
        }
        const transactions = await provider.getTransactions(this.address, lt, hash, limit);
        return transactions.map((tx) => (0, NftItemAction_1.parseNftItemTransaction)(tx));
      }
    };
    exports.NftItem = NftItem;
    NftItem.nftCode = core_1.Cell.fromBase64(nft_item_1.nftItemCode.codeBoc);
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftCollectionData.js
var require_NftCollectionData = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftCollectionData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftCollectionData = exports.storeNftCollectionData = void 0;
    var core_1 = require_dist2();
    var NftRoyaltyParams_1 = require_NftRoyaltyParams();
    function storeNftCollectionData(src) {
      return (builder) => {
        builder.storeAddress(src.admin);
        builder.storeUint(0, 64);
        builder.storeRef(src.content);
        builder.storeRef(src.itemCode);
        builder.storeRef((0, core_1.beginCell)().store((0, NftRoyaltyParams_1.storeNftRoyaltyParams)(src.royalty)).endCell());
      };
    }
    exports.storeNftCollectionData = storeNftCollectionData;
    function loadNftCollectionData(slice) {
      return {
        admin: slice.loadAddress(),
        content: slice.loadRef(),
        itemCode: slice.loadRef(),
        royalty: (0, NftRoyaltyParams_1.loadNftRoyaltyParams)(slice)
      };
    }
    exports.loadNftCollectionData = loadNftCollectionData;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftCollectionMessage.js
var require_NftCollectionMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftCollectionMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadNftCollectionMessage = void 0;
    var opcodes_1 = require_opcodes2();
    var NftMintMessage_1 = require_NftMintMessage();
    var NftBatchMintMessage_1 = require_NftBatchMintMessage();
    var NftChangeAdminMessage_1 = require_NftChangeAdminMessage();
    var NftChangeContentMessage_1 = require_NftChangeContentMessage();
    function loadNftCollectionMessage(slice, paramsValue) {
      try {
        const op = slice.preloadUint(32);
        switch (op) {
          case opcodes_1.NFT_MINT_OPCODE: {
            return { kind: "mint", ...(0, NftMintMessage_1.loadNftMintMessage)(slice, paramsValue.load) };
          }
          case opcodes_1.NFT_BATCH_MINT_OPCODE: {
            return { kind: "mint_batch", ...(0, NftBatchMintMessage_1.loadNftBatchMintMessage)(slice, paramsValue.load) };
          }
          case opcodes_1.NFT_CHANGE_ADMIN_OPCODE: {
            return { kind: "change_admin", ...(0, NftChangeAdminMessage_1.loadNftChangeAdminMessage)(slice) };
          }
          case opcodes_1.NFT_CHANGE_CONTENT_OPCODE: {
            return { kind: "change_content", ...(0, NftChangeContentMessage_1.loadNftChangeContentMessage)(slice) };
          }
        }
      } catch (e) {
      }
      return { kind: "unknown" };
    }
    exports.loadNftCollectionMessage = loadNftCollectionMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/NftCollectionAction.js
var require_NftCollectionAction = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/NftCollectionAction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseNftCollectionTransaction = void 0;
    var NftCollectionMessage_1 = require_NftCollectionMessage();
    var NftItemParams_1 = require_NftItemParams();
    var TransferAction_1 = require_TransferAction();
    function parseNftCollectionTransaction(tx) {
      const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
      if (mayBeTransfer.kind !== "unknown") {
        return mayBeTransfer;
      }
      if (tx.description.type !== "generic") {
        return { kind: "unknown", transaction: tx };
      }
      if (!tx.inMessage) {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.inMessage.info.type !== "internal") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.type !== "vm") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.exitCode !== 0) {
        return { kind: "unknown", transaction: tx };
      }
      const inMessage = (0, NftCollectionMessage_1.loadNftCollectionMessage)(tx.inMessage.body.beginParse(), (0, NftItemParams_1.createNftItemParamsValue)());
      if (inMessage.kind === "mint") {
        return {
          kind: "mint",
          queryId: inMessage.queryId,
          index: inMessage.itemIndex,
          owner: inMessage.itemParams.owner,
          content: inMessage.itemParams.individualContent,
          transaction: tx
        };
      }
      if (inMessage.kind === "mint_batch") {
        return {
          kind: "mint_batch",
          queryId: inMessage.queryId,
          items: inMessage.requests.map((item) => ({
            index: item.index,
            owner: item.params.owner,
            content: item.params.individualContent
          })),
          transaction: tx
        };
      }
      if (inMessage.kind === "change_admin") {
        return {
          kind: "change_owner",
          queryId: inMessage.queryId,
          newOwner: inMessage.newAdmin,
          transaction: tx
        };
      }
      if (inMessage.kind === "change_content") {
        return {
          kind: "change_content",
          queryId: inMessage.queryId,
          newContent: inMessage.newContent,
          newRoyalty: inMessage.newRoyaltyParams,
          transaction: tx
        };
      }
      return { kind: "unknown", transaction: tx };
    }
    exports.parseNftCollectionTransaction = parseNftCollectionTransaction;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/NftCollection.js
var require_NftCollection = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/NftCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NftCollection = exports.nftCollectionConfigToCell = void 0;
    var core_1 = require_dist2();
    var NftCollectionBase_1 = require_NftCollectionBase();
    var NftItem_1 = require_NftItem();
    var NftCollectionData_1 = require_NftCollectionData();
    var NftItemParams_1 = require_NftItemParams();
    var NftCollectionAction_1 = require_NftCollectionAction();
    function nftCollectionConfigToCell(config) {
      var _a, _b, _c;
      return (0, core_1.beginCell)().store((0, NftCollectionData_1.storeNftCollectionData)({
        admin: config.admin,
        content: config.content,
        itemCode: config.itemCode ?? NftItem_1.NftItem.nftCode,
        royalty: {
          numerator: ((_a = config.royalty) == null ? void 0 : _a.numerator) ?? 0n,
          denominator: ((_b = config.royalty) == null ? void 0 : _b.denominator) ?? 1n,
          recipient: ((_c = config.royalty) == null ? void 0 : _c.recipient) ?? config.admin
        }
      })).endCell();
    }
    exports.nftCollectionConfigToCell = nftCollectionConfigToCell;
    var NftCollection = class _NftCollection extends NftCollectionBase_1.NftCollectionBase {
      static createFromConfig(config, code, workchain, contentResolver) {
        const data = nftCollectionConfigToCell(config);
        const init = { data, code: code ?? NftCollectionBase_1.NftCollectionBase.code };
        return new _NftCollection((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver, (0, NftItemParams_1.createNftItemParamsValue)());
      }
      static createFromAddress(address, contentResolver) {
        return new _NftCollection(address, void 0, contentResolver, (0, NftItemParams_1.createNftItemParamsValue)());
      }
      async getItem(provider, index) {
        const nftItemAddress = await this.getItemAddress(provider, index);
        return provider.open(new NftItem_1.NftItem(nftItemAddress, void 0, this.contentResolver));
      }
      async getRoyaltyParams(provider) {
        const { stack } = await provider.get("royalty_params", []);
        return {
          numerator: stack.readBigNumber(),
          denominator: stack.readBigNumber(),
          recipient: stack.readAddress()
        };
      }
      async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
          const state = await provider.getState();
          if (!state.last) {
            return [];
          }
          lt = state.last.lt;
          hash = state.last.hash;
        }
        const messages = await provider.getTransactions(this.address, lt, hash, limit);
        return messages.map((tx) => (0, NftCollectionAction_1.parseNftCollectionTransaction)(tx));
      }
    };
    exports.NftCollection = NftCollection;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/contracts/build/sbt-item.js
var require_sbt_item = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/contracts/build/sbt-item.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sbtItemCode = void 0;
    exports.sbtItemCode = {
      codeBoc: "te6ccgECEwEAAzsAART/APSkE/S88sgLAQIBYgIDAgLOBAUCASAPEAS9RsIiDHAJFb4AHQ0wP6QDDwAvhCs44cMfhDAccF8uGV+kAB+GTUAfhm+kAw+GVw+GfwA+AC0x8CcbDjAgHTP4IQ0MO/6lIwuuMCghAE3tFIUjC64wIwghAvyyaiUiC6gGBwgJAgEgDQ4AlDAx0x+CEAUkx64Suo450z8wgBD4RHCCEMGOhtJVA22AQAPIyx8Syz8hbrOTAc8XkTHiyXEFyMsFUATPFlj6AhPLaszJAfsAkTDiAMJsEvpA1NMAMPhH+EHIy/9QBs8W+ETPFhLMFMs/UjDLAAPDAJb4RlADzALegBB4sXCCEA3WB+NANRSAQAPIyx8Syz8hbrOTAc8XkTHiyXEFyMsFUATPFlj6AhPLaszJAfsAAMYy+ERQA8cF8uGR+kDU0wAw+Ef4QcjL//hEzxYTzBLLP1IQywABwwCU+EYBzN6AEHixcIIQBSTHrkBVA4BAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wAD+o5AMfhByMv/+EPPFoAQcIIQi3cXNUAVUEQDgEADyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AOCCEB8EU3pSILrjAoIQb4n141Iguo4WW/hFAccF8uGR+EfAAPLhk/gj+GfwA+CCENE207NSILrjAjAxCgsMAJIx+EQixwXy4ZGAEHCCENUydtsQJFUCbYMGA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wCLAvhkiwL4ZfADAI4x+EQixwXy4ZGCCvrwgHD7AoAQcIIQ1TJ22xAkVQJtgwYDyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AAAgghBfzD0UupPywZ3ehA/y8ABhO1E0NM/Afhh+kAB+GNw+GIg10nCAI4Wf/hi+kAB+GTUAfhm+kAB+GXTPzD4Z5Ew4oAA3PhH+Eb4QcjLP/hDzxb4RM8WzPhFzxbLP8ntVIAIBWBESAB28fn+AF8IXwg/CH8InwjQADbVjHgBfCLAADbewfgBfCPA="
    };
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/SbtItemParams.js
var require_SbtItemParams = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/SbtItemParams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSbtItemParamsValue = exports.loadSbtItemParams = exports.storeSbtItemParams = void 0;
    var core_1 = require_dist2();
    function storeSbtItemParams(src) {
      return (builder) => {
        builder.storeAddress(src.owner);
        if (typeof src.individualContent === "string") {
          builder.storeRef((0, core_1.beginCell)().storeStringTail(src.individualContent).endCell());
        } else {
          builder.storeRef(src.individualContent);
        }
        builder.storeAddress(src.authority);
      };
    }
    exports.storeSbtItemParams = storeSbtItemParams;
    function loadSbtItemParams(slice) {
      const owner = slice.loadAddress();
      const content = slice.loadRef();
      const authority = slice.loadMaybeAddress();
      return { owner, individualContent: content, authority };
    }
    exports.loadSbtItemParams = loadSbtItemParams;
    function createSbtItemParamsValue() {
      return {
        store: storeSbtItemParams,
        load: loadSbtItemParams
      };
    }
    exports.createSbtItemParamsValue = createSbtItemParamsValue;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/SbtItemAction.js
var require_SbtItemAction = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/SbtItemAction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSbtItemTransaction = void 0;
    var NftMessage_1 = require_NftMessage();
    var TransferAction_1 = require_TransferAction();
    function parseSbtItemTransaction(tx) {
      const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
      if (mayBeTransfer.kind !== "unknown") {
        return mayBeTransfer;
      }
      if (tx.description.type !== "generic") {
        return { kind: "unknown", transaction: tx };
      }
      if (!tx.inMessage) {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.inMessage.info.type !== "internal") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.type !== "vm") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.exitCode !== 0) {
        return { kind: "unknown", transaction: tx };
      }
      const inMessage = (0, NftMessage_1.loadNftMessage)(tx.inMessage.body.beginParse());
      if (inMessage.kind === "nft_deploy") {
        return {
          kind: "sbt_deploy",
          owner: inMessage.owner,
          content: inMessage.content,
          collection: tx.inMessage.info.src,
          transaction: tx
        };
      }
      return { kind: "unknown", transaction: tx };
    }
    exports.parseSbtItemTransaction = parseSbtItemTransaction;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/SbtItem.js
var require_SbtItem = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/SbtItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SbtItem = exports.sbtItemConfigToCell = void 0;
    var core_1 = require_dist2();
    var content_1 = require_content();
    var NftCollection_1 = require_NftCollection();
    var content_2 = require_content3();
    var sbt_item_1 = require_sbt_item();
    var SbtItemParams_1 = require_SbtItemParams();
    var SbtItemAction_1 = require_SbtItemAction();
    function sbtItemConfigToCell(config) {
      return (0, core_1.beginCell)().storeUint(config.index, 64).storeAddress(config.collection).endCell();
    }
    exports.sbtItemConfigToCell = sbtItemConfigToCell;
    var SbtItem = class _SbtItem {
      constructor(address, init, contentResolver) {
        this.address = address;
        this.init = init;
        this.contentResolver = contentResolver;
      }
      static createFromConfig(config, code, workchain, contentResolver) {
        const data = sbtItemConfigToCell(config);
        const init = { data, code: code ?? _SbtItem.sbtCode };
        return new _SbtItem((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
      }
      static createFromAddress(address, contentResolver) {
        return new _SbtItem(address, void 0, contentResolver);
      }
      async sendDeploy(provider, sender, params, value) {
        await provider.internal(sender, {
          value: value ?? (0, core_1.toNano)("0.03"),
          bounce: true,
          body: (0, core_1.beginCell)().store((0, SbtItemParams_1.storeSbtItemParams)(params)).endCell()
        });
      }
      async getData(provider) {
        const { stack } = await provider.get("get_nft_data", []);
        return {
          initialized: stack.readBoolean(),
          index: stack.readBigNumber(),
          collection: stack.readAddressOpt(),
          owner: stack.readAddressOpt(),
          individualContent: stack.readCellOpt()
        };
      }
      async getContent(provider) {
        if (this.contentResolver === void 0) {
          throw new Error("No content resolver");
        }
        const { collection, individualContent, index } = await this.getData(provider);
        if (individualContent === null) {
          throw new Error("Individual content is null");
        }
        let content;
        if (collection === null) {
          content = individualContent;
        } else {
          const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
          content = await collectionContract.getItemContent(index, individualContent);
        }
        return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(content, this.contentResolver));
      }
      async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
          const state = await provider.getState();
          if (!state.last) {
            return [];
          }
          lt = state.last.lt;
          hash = state.last.hash;
        }
        const transactions = await provider.getTransactions(this.address, lt, hash, limit);
        return transactions.map((tx) => (0, SbtItemAction_1.parseSbtItemTransaction)(tx));
      }
    };
    exports.SbtItem = SbtItem;
    SbtItem.sbtCode = core_1.Cell.fromBase64(sbt_item_1.sbtItemCode.codeBoc);
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/types/SbtCollectionAction.js
var require_SbtCollectionAction = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/types/SbtCollectionAction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSbtCollectionTransaction = void 0;
    var SbtItemParams_1 = require_SbtItemParams();
    var NftCollectionMessage_1 = require_NftCollectionMessage();
    function parseSbtCollectionTransaction(tx) {
      if (tx.description.type !== "generic") {
        return { kind: "unknown", transaction: tx };
      }
      if (!tx.inMessage) {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.inMessage.info.type !== "internal") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.type !== "vm") {
        return { kind: "unknown", transaction: tx };
      }
      if (tx.description.computePhase.exitCode !== 0) {
        return { kind: "unknown", transaction: tx };
      }
      const inMessage = (0, NftCollectionMessage_1.loadNftCollectionMessage)(tx.inMessage.body.beginParse(), (0, SbtItemParams_1.createSbtItemParamsValue)());
      if (inMessage.kind === "mint") {
        return {
          kind: "mint",
          index: inMessage.itemIndex,
          owner: inMessage.itemParams.owner,
          content: inMessage.itemParams.individualContent,
          authority: inMessage.itemParams.authority,
          transaction: tx
        };
      }
      if (inMessage.kind === "mint_batch") {
        return {
          kind: "mint_batch",
          items: inMessage.requests.map((item) => ({
            index: item.index,
            owner: item.params.owner,
            content: item.params.individualContent,
            authority: item.params.authority
          })),
          transaction: tx
        };
      }
      if (inMessage.kind === "change_admin") {
        return {
          kind: "change_owner",
          newOwner: inMessage.newAdmin,
          transaction: tx
        };
      }
      if (inMessage.kind === "change_content") {
        return {
          kind: "change_content",
          newContent: inMessage.newContent,
          newRoyalty: inMessage.newRoyaltyParams,
          transaction: tx
        };
      }
      return { kind: "unknown", transaction: tx };
    }
    exports.parseSbtCollectionTransaction = parseSbtCollectionTransaction;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/SbtCollection.js
var require_SbtCollection = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/SbtCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SbtCollection = exports.sbtCollectionConfigToCell = void 0;
    var core_1 = require_dist2();
    var NftCollectionBase_1 = require_NftCollectionBase();
    var SbtItem_1 = require_SbtItem();
    var SbtCollectionAction_1 = require_SbtCollectionAction();
    var NftCollectionData_1 = require_NftCollectionData();
    var SbtItemParams_1 = require_SbtItemParams();
    function sbtCollectionConfigToCell(config) {
      return (0, core_1.beginCell)().store((0, NftCollectionData_1.storeNftCollectionData)({
        admin: config.admin,
        content: config.content,
        itemCode: config.itemCode ?? SbtItem_1.SbtItem.sbtCode,
        royalty: {
          numerator: 0n,
          denominator: 1n,
          recipient: config.admin
        }
      })).endCell();
    }
    exports.sbtCollectionConfigToCell = sbtCollectionConfigToCell;
    var SbtCollection = class _SbtCollection extends NftCollectionBase_1.NftCollectionBase {
      static createFromConfig(config, code, workchain, contentResolver) {
        const data = sbtCollectionConfigToCell(config);
        const init = { data, code: code ?? _SbtCollection.code };
        return new _SbtCollection((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver, (0, SbtItemParams_1.createSbtItemParamsValue)());
      }
      static createFromAddress(address, contentResolver) {
        return new _SbtCollection(address, void 0, contentResolver, (0, SbtItemParams_1.createSbtItemParamsValue)());
      }
      async getItem(provider, index) {
        const nftItemAddress = await this.getItemAddress(provider, index);
        return provider.open(new SbtItem_1.SbtItem(nftItemAddress, void 0, this.contentResolver));
      }
      async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
          const state = await provider.getState();
          if (!state.last) {
            return [];
          }
          lt = state.last.lt;
          hash = state.last.hash;
        }
        const messages = await provider.getTransactions(this.address, lt, hash, limit);
        return messages.map((tx) => (0, SbtCollectionAction_1.parseSbtCollectionTransaction)(tx));
      }
    };
    exports.SbtCollection = SbtCollection;
  }
});

// node_modules/@ton-community/assets-sdk/dist/nft/NftSale.js
var require_NftSale = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/nft/NftSale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NftSale = void 0;
    var core_1 = require_dist2();
    var NftSale = class _NftSale {
      constructor(address, init) {
        this.address = address;
        this.init = init;
      }
      static createFromConfig(params, code, workchain) {
        const data = (0, core_1.beginCell)().storeBit(false).storeUint(params.createdAt, 32).storeAddress(params.marketplace).storeAddress(params.nft).storeAddress(null).storeCoins(params.fullPrice).storeRef((0, core_1.beginCell)().storeAddress(params.marketplaceFeeTo).storeCoins(params.marketplaceFee).storeAddress(params.royaltyTo).storeCoins(params.royalty)).storeBit(params.canDeployByExternal).endCell();
        const init = { data, code: code ?? _NftSale.code };
        return new _NftSale((0, core_1.contractAddress)(workchain ?? 0, init), init);
      }
      static createFromAddress(address) {
        return new _NftSale(address);
      }
      async sendDeploy(provider, sender, value) {
        await provider.internal(sender, {
          value: value ?? (0, core_1.toNano)("1"),
          bounce: true,
          sendMode: core_1.SendMode.PAY_GAS_SEPARATELY
        });
      }
      async sendDeployExternal(provider) {
        await provider.external(new core_1.Cell());
      }
      async sendTopup(provider, sender, options) {
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
          body: (0, core_1.beginCell)().storeUint(1, 32).storeUint((options == null ? void 0 : options.queryId) ?? 0, 64).endCell()
        });
      }
      async sendAdminMessage(provider, sender, params, value, queryId) {
        const builder = (0, core_1.beginCell)().storeUint(555, 32).storeUint(queryId ?? 0, 64);
        if (params.message instanceof core_1.Cell) {
          builder.storeRef(builder);
        } else {
          builder.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(params.message)));
        }
        await provider.internal(sender, {
          value: value ?? (0, core_1.toNano)("0.05"),
          bounce: true,
          sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
          body: builder.storeUint(params.sendMode, 8).endCell()
        });
      }
      async sendCancel(provider, sender, options) {
        const { isComplete } = await this.getData(provider);
        if (isComplete) {
          throw new Error("Sale is complete");
        }
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? (0, core_1.toNano)("1"),
          bounce: true,
          sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
          body: (0, core_1.beginCell)().storeUint(3, 32).storeUint((options == null ? void 0 : options.queryId) ?? 0, 64).endCell()
        });
      }
      async sendBuy(provider, sender, options) {
        const { isComplete, nftOwner, fullPrice } = await this.getData(provider);
        if (!isComplete) {
          throw new Error("Sale is not complete");
        }
        if (nftOwner === null) {
          throw new Error("NFT owner is not set");
        }
        await provider.internal(sender, {
          value: (options == null ? void 0 : options.value) ?? fullPrice + (0, core_1.toNano)(1),
          bounce: true,
          sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
          body: (0, core_1.beginCell)().storeUint(2, 32).storeUint((options == null ? void 0 : options.queryId) ?? 0, 64).endCell()
        });
      }
      async getData(provider) {
        const { stack } = await provider.get("get_sale_data", []);
        return {
          type: stack.readNumber(),
          isComplete: stack.readBoolean(),
          createdAt: stack.readNumber(),
          marketplace: stack.readAddress(),
          nft: stack.readAddress(),
          nftOwner: stack.readAddressOpt(),
          fullPrice: stack.readBigNumber(),
          marketplaceFeeTo: stack.readAddress(),
          marketplaceFee: stack.readBigNumber(),
          royaltyTo: stack.readAddressOpt(),
          royalty: stack.readBigNumber()
        };
      }
    };
    exports.NftSale = NftSale;
    NftSale.code = core_1.Cell.fromBase64("te6cckECCwEAArkAART/APSkE/S88sgLAQIBIAMCAH7yMO1E0NMA0x/6QPpA+kD6ANTTADDAAY4d+ABwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgXweCAP/+8vACAUgFBABXoDhZ2omhpgGmP/SB9IH0gfQBqaYAYGGh9IH0AfSB9ABhBCCMkrCgFYACqwECAs0IBgH3ZghA7msoAUmCgUjC+8uHCJND6QPoA+kD6ADBTkqEhoVCHoRagUpBwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhdQRXCAEMjLBVADzxYB+gLLaslx+wAQI5I0NOJacIAQyMsFUAPPFgH6AstqyXH7AHAgghBfzD0UgcAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVAH30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEqYhOmPhW8Q4YBKGATpn8cIxbMbC3MbK2QV44LJOZlvKAVxFWAAyS+G8BJrpOEBFcCBFd0VYACRWdjYKdxjgthOjq+G6hhoaYPqGAD9gHAU4ADAkB6PLRlLOOQjEzOTlTUscFkl8J4FFRxwXy4fSCEAUTjZEWuvLh9QP6QDBGUBA0WXAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVOAwNyjAA+MCKMAAnDY3EDhHZRRDMHDwBeAIwAKYVUQQJBAj8AXgXwqED/LwCgDUODmCEDuaygAYvvLhyVNGxwVRUscFFbHy4cpwIIIQX8w9FCGAEMjLBSjPFiH6Astqyx8Vyz8nzxYnzxYUygAj+gITygDJgwb7AHFQZkUVBHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVOBqUYM=");
  }
});

// node_modules/@ton-community/assets-sdk/dist/storage/noop.js
var require_noop = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/storage/noop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopStorage = void 0;
    var NoopStorage = class {
      async uploadFile(contents) {
        throw new Error(`No storage provider configured`);
      }
    };
    exports.NoopStorage = NoopStorage;
  }
});

// browser-external:chalk
var require_chalk = __commonJS({
  "browser-external:chalk"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "chalk" has been externalized for browser compatibility. Cannot access "chalk.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:boxen
var require_boxen = __commonJS({
  "browser-external:boxen"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "boxen" has been externalized for browser compatibility. Cannot access "boxen.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@ton-community/assets-sdk/dist/cli/common.js
var require_common = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/cli/common.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retry = exports.formatAddressLink = exports.formatAddress = exports.printAddress = exports.printInfo = exports.createEnv = exports.createContentResolver = exports.createStorageEnv = void 0;
    var core_1 = require_dist2();
    var __1 = require_dist4();
    var content_1 = require_content();
    var chalk_1 = __importDefault(require_chalk());
    var boxen_1 = __importDefault(require_boxen());
    function createStorageEnv() {
      if (process.env.STORAGE_TYPE === void 0)
        throw new Error("No STORAGE_TYPE in env!");
      if (process.env.STORAGE_TYPE === "pinata") {
        if (process.env.PINATA_API_KEY === void 0)
          throw new Error("No PINATA_API_KEY in env!");
        if (process.env.PINATA_SECRET_KEY === void 0)
          throw new Error("No PINATA_SECRET_KEY in env!");
        return new __1.PinataStorage(process.env.PINATA_API_KEY, process.env.PINATA_SECRET_KEY);
      } else if (process.env.STORAGE_TYPE === "s3") {
        if (process.env.S3_ACCESS_KEY_ID === void 0)
          throw new Error("No S3_ACCESS_KEY_ID in env!");
        if (process.env.S3_SECRET_ACCESS_KEY === void 0)
          throw new Error("No S3_SECRET_ACCESS_KEY in env!");
        if (process.env.S3_BUCKET === void 0)
          throw new Error("No S3_BUCKET in env!");
        return new __1.S3Storage(process.env.S3_ACCESS_KEY_ID, process.env.S3_SECRET_ACCESS_KEY, process.env.S3_BUCKET);
      }
      throw new Error(`Unknown storage type: ${process.env.STORAGE_TYPE}`);
    }
    exports.createStorageEnv = createStorageEnv;
    function createContentResolver() {
      if (process.env.IPFS_GATEWAY_TYPE === void 0)
        throw new Error("No IPFS_GATEWAY_TYPE in env!");
      if (process.env.IPFS_GATEWAY_TYPE === "ipfs.io") {
        return new content_1.DefaultContentResolver((id) => `https://ipfs.io/ipfs/${id}`);
      }
      if (process.env.IPFS_GATEWAY_TYPE === "https") {
        if (process.env.IPFS_GATEWAY === void 0)
          throw new Error("No IPFS_GATEWAY in env!");
        const ipfsGateway = new URL(process.env.IPFS_GATEWAY);
        return new content_1.DefaultContentResolver((id) => {
          ipfsGateway.pathname = "/ipfs/" + id;
          return ipfsGateway.toString();
        });
      }
      if (process.env.IPFS_GATEWAY_TYPE === "pinata") {
        if (process.env.IPFS_GATEWAY === void 0)
          throw new Error("No IPFS_GATEWAY in env!");
        if (process.env.IPFS_GATEWAY_API_KEY === void 0)
          throw new Error("No IPFS_GATEWAY_API_KEY in env!");
        const ipfsGateway = new URL(process.env.IPFS_GATEWAY);
        return new content_1.DefaultContentResolver((id) => {
          ipfsGateway.pathname = "/ipfs/" + id;
          ipfsGateway.searchParams.set("pinataGatewayToken", process.env.IPFS_GATEWAY_API_KEY);
          return ipfsGateway.toString();
        });
      }
      throw new Error(`Unknown IPFS gateway type: ${process.env.IPFS_GATEWAY_TYPE}`);
    }
    exports.createContentResolver = createContentResolver;
    async function createEnv() {
      if (process.env.WALLET_TYPE === void 0)
        throw new Error("No WALLET_TYPE in env!");
      if (process.env.WALLET_TYPE !== "highload-v2")
        throw new Error(`Unknown wallet type: ${process.env.WALLET_TYPE}`);
      if (process.env.MNEMONIC === void 0)
        throw new Error("No MNEMONIC in env!");
      if (process.env.NETWORK === void 0)
        throw new Error("No NETWORK in env!");
      if (process.env.NETWORK !== "mainnet" && process.env.NETWORK !== "testnet")
        throw new Error(`Unknown network: ${process.env.NETWORK}`);
      const contentResolver = createContentResolver();
      const storage = createStorageEnv();
      const client = await (0, __1.createApi)(process.env.NETWORK);
      const keyPair = await (0, __1.importKey)(process.env.MNEMONIC);
      const { publicKey, secretKey } = keyPair;
      const walletContract = await (0, __1.createWallet)(process.env.WALLET_TYPE, publicKey);
      const sender = client.open(walletContract).sender(keyPair.secretKey);
      const sdk = __1.AssetsSDK.create({
        storage,
        api: client,
        sender,
        contentResolver
      });
      return {
        sdk,
        network: process.env.NETWORK,
        storage,
        sender,
        client
      };
    }
    exports.createEnv = createEnv;
    function printInfo(info, network) {
      var _a;
      const keys = Object.keys(info);
      const rows = [];
      for (const key of keys) {
        let value = info[key];
        if (typeof value === "string") {
          value = chalk_1.default.green(value);
        } else if (typeof value === "bigint") {
          value = chalk_1.default.yellow(value.toString());
        } else if (typeof value === "number") {
          value = chalk_1.default.cyan(value);
        } else if (typeof value === "boolean") {
          value = chalk_1.default.blue(value);
        } else if (value === null) {
          value = chalk_1.default.red("null");
        } else if (value === void 0) {
          value = chalk_1.default.red("undefined");
        } else if (core_1.Address.isAddress(value)) {
          value = `${chalk_1.default.magenta(formatAddress(value, network))} ${chalk_1.default.blue(formatAddressLink(value, network))}`;
        } else if (value instanceof core_1.Cell) {
          value = chalk_1.default.blue(value.toString("base64"));
        } else {
          throw new Error(`Unknown type: ${typeof value}`);
        }
        rows.push([key, value]);
      }
      console.log((0, boxen_1.default)(rows.filter(([key]) => key !== "name").map(([key, value]) => `${chalk_1.default.bold(key)}: ${value}`).join("\n"), {
        padding: {
          top: 0,
          bottom: 0,
          left: 1,
          right: 1
        },
        borderStyle: "round",
        borderColor: "green",
        title: (_a = rows.find(([key, value]) => key === "name")) == null ? void 0 : _a[1]
      }));
    }
    exports.printInfo = printInfo;
    function printAddress(address, network, name = "wallet") {
      const formattedAddress = formatAddress(address, network);
      const formattedAddressLink = formatAddressLink(address, network);
      console.log(`Your ${name} has the address ${formattedAddress}
You can view it at ${formattedAddressLink}`);
    }
    exports.printAddress = printAddress;
    function formatAddress(address, network) {
      if (!address) {
        return "null";
      }
      return address.toString({ testOnly: network === "testnet", bounceable: true });
    }
    exports.formatAddress = formatAddress;
    function formatAddressLink(address, network) {
      if (!address) {
        return "null";
      }
      return `https://${network === "testnet" ? "testnet." : ""}tonviewer.com/${formatAddress(address, network)}`;
    }
    exports.formatAddressLink = formatAddressLink;
    async function retry(fn, options) {
      let { retries, delay, name } = { retries: 3, delay: 1e3, ...options };
      for (let i = 0; i < retries; i++) {
        try {
          return await fn();
        } catch (e) {
          console.log(`Attempt ${i + 1} failed: ${name ? name + ": " : ""}${e}`);
        }
        await new Promise((resolve) => setTimeout(resolve, delay * 2 ** i));
      }
      throw new Error("Exceeded number of retries");
    }
    exports.retry = retry;
  }
});

// node_modules/@ton-community/assets-sdk/dist/sdk.js
var require_sdk2 = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/sdk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssetsSDK = void 0;
    var core_1 = require_dist2();
    var pinata_1 = require_pinata();
    var s3_1 = require_s3();
    var content_1 = require_content2();
    var content_2 = require_content3();
    var utils_1 = require_utils();
    var JettonWallet_1 = require_JettonWallet();
    var JettonMinter_1 = require_JettonMinter();
    var NftCollection_1 = require_NftCollection();
    var NftItem_1 = require_NftItem();
    var SbtCollection_1 = require_SbtCollection();
    var content_3 = require_content();
    var NftSale_1 = require_NftSale();
    var noop_1 = require_noop();
    var common_1 = require_common();
    var WORKCHAIN = 0;
    var AssetsSDK = class _AssetsSDK {
      constructor(storage, api, sender, contentResolver) {
        this.storage = storage;
        this.api = api;
        this.sender = sender;
        this.contentResolver = contentResolver;
      }
      static create(params) {
        let { api, storage, sender, contentResolver } = params;
        if (!storage) {
          storage = new noop_1.NoopStorage();
        } else if ("pinataApiKey" in storage) {
          storage = pinata_1.PinataStorage.create(storage);
        } else if ("s3AccessKeyId" in storage) {
          storage = s3_1.S3Storage.create(storage);
        }
        contentResolver ?? (contentResolver = new content_3.DefaultContentResolver());
        return new _AssetsSDK(storage, api, sender, contentResolver);
      }
      async deployJetton(content, options) {
        var _a;
        if (!this.sender) {
          throw new Error("Sender must be defined");
        }
        const adminAddress = (options == null ? void 0 : options.adminAddress) ?? ((_a = this.sender) == null ? void 0 : _a.address);
        if (adminAddress === void 0) {
          throw new Error("Admin address must be defined in options or be available in Sender");
        }
        const jettonMinterContract = JettonMinter_1.JettonMinter.createFromConfig({
          admin: adminAddress,
          content: await this.contentToCell((0, content_1.jettonContentToInternal)(content), (options == null ? void 0 : options.onchainContent) ?? false)
        }, JettonMinter_1.JettonMinter.code, WORKCHAIN, this.contentResolver);
        const jetton = this.api.open(jettonMinterContract);
        const premintAmount = options == null ? void 0 : options.premintAmount;
        if (typeof premintAmount === "bigint" && premintAmount > 0n) {
          await jetton.sendMint(this.sender, adminAddress, premintAmount, {
            ...options == null ? void 0 : options.premintOptions,
            value: options == null ? void 0 : options.value,
            queryId: options == null ? void 0 : options.queryId
          });
        } else {
          await jetton.sendDeploy(this.sender, options == null ? void 0 : options.value);
        }
        return jetton;
      }
      openJetton(address) {
        return this.api.open(JettonMinter_1.JettonMinter.createFromAddress(address, this.contentResolver));
      }
      async deployNftCollection(content, options) {
        var _a, _b;
        if (!this.sender) {
          throw new Error("Sender must be defined");
        }
        const adminAddress = (options == null ? void 0 : options.adminAddress) ?? ((_a = this.sender) == null ? void 0 : _a.address);
        if (adminAddress === void 0) {
          throw new Error("Admin address must be defined in options or be available in Sender");
        }
        const collection = this.api.open(NftCollection_1.NftCollection.createFromConfig({
          admin: adminAddress,
          content: (0, core_1.beginCell)().storeRef(await this.contentToCell((0, content_2.nftContentToInternal)(content.collectionContent), (options == null ? void 0 : options.onchainContent) ?? false)).storeRef((0, core_1.beginCell)().storeStringTail(content.commonContent)).endCell(),
          royalty: options == null ? void 0 : options.royaltyParams
        }, NftCollection_1.NftCollection.code, WORKCHAIN, this.contentResolver));
        if (typeof ((_b = options == null ? void 0 : options.premintItems) == null ? void 0 : _b.length) === "number" && (options == null ? void 0 : options.premintItems.length) > 0) {
          await collection.sendBatchMint(this.sender, options == null ? void 0 : options.premintItems, {
            value: options == null ? void 0 : options.value,
            queryId: options == null ? void 0 : options.queryId
          });
        } else {
          await collection.sendDeploy(this.sender, options == null ? void 0 : options.value);
        }
        return collection;
      }
      openNftCollection(address) {
        return this.api.open(NftCollection_1.NftCollection.createFromAddress(address, this.contentResolver));
      }
      async deploySbtCollection(content, options) {
        var _a, _b;
        if (!this.sender) {
          throw new Error("Sender must be defined");
        }
        const adminAddress = (options == null ? void 0 : options.adminAddress) ?? ((_a = this.sender) == null ? void 0 : _a.address);
        if (adminAddress === void 0) {
          throw new Error("Admin address must be defined in options or be available in Sender");
        }
        const collection = this.api.open(SbtCollection_1.SbtCollection.createFromConfig({
          admin: adminAddress,
          content: (0, core_1.beginCell)().storeRef(await this.contentToCell((0, content_2.nftContentToInternal)(content.collectionContent), (content == null ? void 0 : content.onchainContent) ?? false)).storeRef((0, core_1.beginCell)().storeStringTail(content.commonContent)).endCell()
        }, SbtCollection_1.SbtCollection.code, WORKCHAIN, this.contentResolver));
        if (typeof ((_b = options == null ? void 0 : options.premintItems) == null ? void 0 : _b.length) === "number" && (options == null ? void 0 : options.premintItems.length) > 0) {
          await collection.sendBatchMint(this.sender, options == null ? void 0 : options.premintItems, {
            value: options == null ? void 0 : options.value,
            queryId: options == null ? void 0 : options.queryId
          });
        } else {
          await collection.sendDeploy(this.sender, options == null ? void 0 : options.value);
        }
        return collection;
      }
      openSbtCollection(address) {
        return this.api.open(SbtCollection_1.SbtCollection.createFromAddress(address, this.contentResolver));
      }
      openJettonWallet(address) {
        return this.api.open(new JettonWallet_1.JettonWallet(address));
      }
      openNftItem(address) {
        return this.api.open(new NftItem_1.NftItem(address, void 0, this.contentResolver));
      }
      async deployNftSale(params) {
        var _a;
        if (!this.sender) {
          throw new Error("Sender must be defined");
        }
        const marketplaceAddress = params.marketplace ?? ((_a = this.sender) == null ? void 0 : _a.address);
        if (marketplaceAddress === void 0) {
          throw new Error("Marketplace address must be defined in options or be available in Sender");
        }
        const sale = this.api.open(NftSale_1.NftSale.createFromConfig({
          createdAt: params.createdAt ?? Math.floor(Date.now() / 1e3),
          marketplace: params.marketplace ?? null,
          nft: params.nft,
          fullPrice: params.fullPrice,
          marketplaceFeeTo: params.marketplaceFeeTo ?? null,
          marketplaceFee: params.marketplaceFee ?? 0n,
          royaltyTo: params.royaltyTo ?? null,
          royalty: params.royalty ?? 0n,
          canDeployByExternal: params.canDeployByExternal ?? true
        }));
        await sale.sendTopup(this.sender, { value: params.value, queryId: params.queryId });
        return sale;
      }
      openNftSale(address) {
        return this.api.open(NftSale_1.NftSale.createFromAddress(address));
      }
      async internalOffchainContentToCell(internal) {
        const contents = Buffer.from(JSON.stringify(internal), "utf-8");
        const contentUrl = await (0, common_1.retry)(() => this.storage.uploadFile(contents), { name: "upload content" });
        return (0, core_1.beginCell)().storeUint(1, 8).storeStringTail(contentUrl).endCell();
      }
      async contentToCell(internal, onchain) {
        return onchain ? (0, utils_1.internalOnchainContentToCell)(internal) : await this.internalOffchainContentToCell(internal);
      }
    };
    exports.AssetsSDK = AssetsSDK;
  }
});

// node_modules/whatwg-fetch/fetch.js
var fetch_exports = {};
__export(fetch_exports, {
  DOMException: () => DOMException,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  fetch: () => fetch2
});
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
}
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
function fetch2(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
var g, support, viewClasses, isArrayBufferView, methods, redirectStatuses, DOMException;
var init_fetch = __esm({
  "node_modules/whatwg-fetch/fetch.js"() {
    g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
    typeof global !== "undefined" && global || {};
    support = {
      searchParams: "URLSearchParams" in g,
      iterable: "Symbol" in g && "iterator" in Symbol,
      blob: "FileReader" in g && "Blob" in g && function() {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: "FormData" in g,
      arrayBuffer: "ArrayBuffer" in g
    };
    if (support.arrayBuffer) {
      viewClasses = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
      ];
      isArrayBufferView = ArrayBuffer.isView || function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }
    Headers.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ", " + value : value;
    };
    Headers.prototype["delete"] = function(name) {
      delete this.map[normalizeName(name)];
    };
    Headers.prototype.get = function(name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null;
    };
    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };
    Headers.prototype.forEach = function(callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };
    Headers.prototype.keys = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };
    Headers.prototype.values = function() {
      var items = [];
      this.forEach(function(value) {
        items.push(value);
      });
      return iteratorFor(items);
    };
    Headers.prototype.entries = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };
    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }
    methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
    Request.prototype.clone = function() {
      return new Request(this, { body: this._bodyInit });
    };
    Body.call(Request.prototype);
    Body.call(Response.prototype);
    Response.prototype.clone = function() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };
    Response.error = function() {
      var response = new Response(null, { status: 200, statusText: "" });
      response.ok = false;
      response.status = 0;
      response.type = "error";
      return response;
    };
    redirectStatuses = [301, 302, 303, 307, 308];
    Response.redirect = function(url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError("Invalid status code");
      }
      return new Response(null, { status, headers: { location: url } });
    };
    DOMException = g.DOMException;
    try {
      new DOMException();
    } catch (err) {
      DOMException = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };
      DOMException.prototype = Object.create(Error.prototype);
      DOMException.prototype.constructor = DOMException;
    }
    fetch2.polyfill = true;
    if (!g.fetch) {
      g.fetch = fetch2;
      g.Headers = Headers;
      g.Request = Request;
      g.Response = Response;
    }
  }
});

// node_modules/isomorphic-fetch/fetch-npm-browserify.js
var require_fetch_npm_browserify = __commonJS({
  "node_modules/isomorphic-fetch/fetch-npm-browserify.js"(exports, module) {
    init_fetch();
    module.exports = self.fetch.bind(self);
  }
});

// node_modules/@orbs-network/ton-access/lib/nodes.js
var require_nodes = __commonJS({
  "node_modules/@orbs-network/ton-access/lib/nodes.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Nodes = void 0;
    require_fetch_npm_browserify();
    var Nodes = class {
      ///////////////////////////////////
      constructor() {
        this.nodeIndex = -1;
        this.committee = /* @__PURE__ */ new Set();
        this.topology = [];
        this.initTime = 0;
      }
      ///////////////////////////////////
      init(nodesUrl) {
        return __awaiter(this, void 0, void 0, function* () {
          this.nodeIndex = -1;
          this.committee.clear();
          this.topology = [];
          this.initTime = Date.now();
          let topology = [];
          try {
            const response = yield fetch(nodesUrl);
            const data = yield response.json();
            topology = data;
          } catch (e) {
            throw new Error(`exception in fetch(${nodesUrl}): ${e}`);
          }
          for (const node of topology) {
            if (node.Healthy === "1") {
              this.topology.push(node);
            }
          }
          if (this.topology.length === 0)
            throw new Error(`no healthy nodes in ${nodesUrl}`);
        });
      }
      getHealthyFor(protonet) {
        var _a;
        const res = [];
        for (const node of this.topology) {
          if (node.Weight > 0 && ((_a = node.Mngr) === null || _a === void 0 ? void 0 : _a.health[protonet])) {
            res.push(node);
          }
        }
        return res;
      }
    };
    exports.Nodes = Nodes;
  }
});

// node_modules/@orbs-network/ton-access/package.json
var require_package = __commonJS({
  "node_modules/@orbs-network/ton-access/package.json"(exports, module) {
    module.exports = {
      name: "@orbs-network/ton-access",
      version: "2.3.3",
      description: "Unthrottled anonymous RPC access to TON blockchain via a robust decentralized network",
      source: "lib/index.js",
      main: "lib/index.js",
      types: "lib/index.d.ts",
      files: [
        "lib/**/*"
      ],
      scripts: {
        test: "env mocha -r ts-node/register test/**/*.ts",
        "test:v2": "env mocha -r ts-node/register test/ton-v2.ts",
        "test:v4": "env mocha -r ts-node/register test/ton-v4.ts",
        cleanup: "rimraf ./lib",
        "build:web:reg": "esbuild ./lib/web.js --bundle  --sourcemap --target=es2015 --outfile=./dist/index.js",
        "build:web:min": "esbuild ./lib/web.js --bundle  --minify    --target=es2015 --outfile=./dist/index.min.js",
        "build:web": "rimraf ./dist && npm run build:web:reg && npm run build:web:min",
        build: "npm run lint && rimraf ./lib && tsc && npm run build:web",
        format: 'prettier --write "src/**/*.ts"',
        lint: "tslint -p tsconfig.json",
        prepare: "npm run build",
        prepublishOnly: "npm test && npm run lint",
        preversion: "npm run lint",
        version: "npm run format && git add -A src",
        postversion: "git push && git push --tags"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/orbs-network/ton-access.git"
      },
      author: "yuval@orbs.com",
      license: "MIT",
      bugs: {
        url: "https://github.com/orbs-network/ton-access/issues"
      },
      homepage: "https://github.com/orbs-network/ton-access#readme",
      dependencies: {
        "isomorphic-fetch": "^3.0.0"
      },
      devDependencies: {
        "@types/bn.js": "^5.1.1",
        "@types/chai": "^4.3.4",
        "@types/isomorphic-fetch": "^0.0.36",
        "@types/mocha": "^10.0.0",
        buffer: "^6.0.3",
        chai: "^4.3.7",
        esbuild: "^0.15.14",
        mocha: "^10.1.0",
        prettier: "^2.7.1",
        rimraf: "^3.0.2",
        ton: "^12.1.3",
        "ton-lite-client": "npm:@truecarry/ton-lite-client@^1.6.1",
        tonweb: "^0.0.58",
        "ts-node": "^10.9.1",
        tslib: "^2.4.0",
        tslint: "^6.1.3",
        "tslint-config-prettier": "^1.18.0"
      }
    };
  }
});

// node_modules/@orbs-network/ton-access/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@orbs-network/ton-access/lib/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHttpV4Endpoint = exports.getHttpV4Endpoints = exports.getHttpEndpoint = exports.getHttpEndpoints = exports.Access = void 0;
    var nodes_1 = require_nodes();
    var Access = class {
      //////////////////////////////////
      constructor() {
        this.host = "ton.access.orbs.network";
        this.urlVersion = 1;
        this.nodes = new nodes_1.Nodes();
      }
      //////////////////////////////////
      init() {
        return __awaiter(this, void 0, void 0, function* () {
          const pjson = require_package();
          yield this.nodes.init(`https://${this.host}/mngr/nodes?npm_version=${pjson.version}`);
        });
      }
      //////////////////////////////////
      makeProtonet(edgeProtocol, network) {
        let res = "";
        switch (edgeProtocol) {
          case "toncenter-api-v2":
            res += "v2-";
            break;
          case "ton-api-v4":
            res += "v4-";
            break;
        }
        res += network;
        return res;
      }
      //////////////////////////////////
      weightedRandom(nodes) {
        let sumWeights = 0;
        for (const node of nodes) {
          sumWeights += node.Weight;
        }
        const rnd = Math.floor(Math.random() * sumWeights);
        let cur = 0;
        for (const node of nodes) {
          if (rnd >= cur && rnd < cur + node.Weight)
            return node;
          cur += node.Weight;
        }
      }
      //////////////////////////////////
      buildUrls(network, edgeProtocol, suffix, single) {
        if (!suffix)
          suffix = "";
        if (!edgeProtocol)
          edgeProtocol = "toncenter-api-v2";
        if (!network)
          network = "mainnet";
        if (suffix.length)
          suffix = suffix.replace(/^\/+/, "");
        const res = [];
        const protonet = this.makeProtonet(edgeProtocol, network);
        let healthyNodes = this.nodes.getHealthyFor(protonet);
        if (!(healthyNodes === null || healthyNodes === void 0 ? void 0 : healthyNodes.length))
          throw new Error(`no healthy nodes for ${protonet}`);
        if (single && healthyNodes.length) {
          const chosen = this.weightedRandom(healthyNodes);
          if (chosen)
            healthyNodes = [chosen];
          else
            throw new Error("weightedRandom return empty");
        }
        for (const node of healthyNodes) {
          let url = `https://${this.host}/${node.NodeId}/${this.urlVersion}/${network}/${edgeProtocol}`;
          if (suffix.length)
            url += `/${suffix}`;
          res.push(url);
        }
        return res;
      }
    };
    exports.Access = Access;
    function getEndpoints(network, edgeProtocol, suffix, single) {
      return __awaiter(this, void 0, void 0, function* () {
        const access = new Access();
        yield access.init();
        const res = access.buildUrls(network, edgeProtocol, suffix, single);
        return res;
      });
    }
    function getHttpEndpoints(config, single) {
      return __awaiter(this, void 0, void 0, function* () {
        const network = (config === null || config === void 0 ? void 0 : config.network) ? config.network : "mainnet";
        let suffix = "jsonRPC";
        if ((config === null || config === void 0 ? void 0 : config.protocol) === "rest") {
          suffix = "";
        }
        return yield getEndpoints(network, "toncenter-api-v2", suffix, single);
      });
    }
    exports.getHttpEndpoints = getHttpEndpoints;
    function getHttpEndpoint(config) {
      return __awaiter(this, void 0, void 0, function* () {
        const endpoints = yield getHttpEndpoints(config, true);
        return endpoints[0];
      });
    }
    exports.getHttpEndpoint = getHttpEndpoint;
    function getHttpV4Endpoints(config, single) {
      return __awaiter(this, void 0, void 0, function* () {
        const network = (config === null || config === void 0 ? void 0 : config.network) ? config.network : "mainnet";
        if ((config === null || config === void 0 ? void 0 : config.protocol) === "json-rpc") {
          throw Error("config.protocol json-rpc is not supported for getTonApiV4Endpoints");
        }
        const suffix = "";
        return yield getEndpoints(network, "ton-api-v4", suffix, single);
      });
    }
    exports.getHttpV4Endpoints = getHttpV4Endpoints;
    function getHttpV4Endpoint(config) {
      return __awaiter(this, void 0, void 0, function* () {
        const endpoints = yield getHttpV4Endpoints(config, true);
        return endpoints[0];
      });
    }
    exports.getHttpV4Endpoint = getHttpV4Endpoint;
  }
});

// node_modules/@ton-community/assets-sdk/dist/client/ton-client-api.js
var require_ton_client_api = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/client/ton-client-api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createApi = void 0;
    var ton_1 = require_dist3();
    var ton_access_1 = require_lib2();
    async function createApi(network) {
      const endpoint = await (0, ton_access_1.getHttpV4Endpoint)({ network });
      return new ton_1.TonClient4({ endpoint, timeout: 15e3 });
    }
    exports.createApi = createApi;
  }
});

// node_modules/@ton-community/assets-sdk/dist/key.js
var require_key = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importKey = void 0;
    var crypto_1 = require_dist();
    async function importKey(key) {
      if (typeof key === "string") {
        return await (0, crypto_1.mnemonicToWalletKey)(key.split(" "));
      } else if (Array.isArray(key)) {
        return await (0, crypto_1.mnemonicToWalletKey)(key);
      } else {
        return (0, crypto_1.keyPairFromSecretKey)(key);
      }
    }
    exports.importKey = importKey;
  }
});

// node_modules/@ton-community/assets-sdk/dist/wallets/HighloadWalletContractV2.js
var require_HighloadWalletContractV2 = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/wallets/HighloadWalletContractV2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HighloadWalletContractV2 = void 0;
    var core_1 = require_dist2();
    var crypto_1 = require_dist();
    var utils_1 = require_utils();
    var HighloadWalletContractV2 = class _HighloadWalletContractV2 {
      constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== void 0) {
          this.walletId = walletId;
        } else {
          this.walletId = 698983191 + workchain;
        }
        const code = core_1.Cell.fromBase64("te6cckEBCQEA5QABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQHq8oMI1xgg0x/TP/gjqh9TILnyY+1E0NMf0z/T//QE0VNggED0Dm+hMfJgUXO68qIH+QFUEIf5EPKjAvQE0fgAf44WIYAQ9HhvpSCYAtMH1DAB+wCRMuIBs+ZbgyWhyEA0gED0Q4rmMQHIyx8Tyz/L//QAye1UCAAE0DACASAGBwAXvZznaiaGmvmOuF/8AEG+X5dqJoaY+Y6Z/p/5j6AmipEEAgegc30JjJLb/JXdHxQANCCAQPSWb6VsEiCUMFMDud4gkzM2AZJsIeKzn55UWg==");
        const data = (0, core_1.beginCell)().storeUint(this.walletId, 32).storeUint(0, 64).storeBuffer(this.publicKey, 32).storeDict(null).endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(this.workchain, this.init);
      }
      static create(args) {
        return new _HighloadWalletContractV2(args.workchain, args.publicKey, args.walletId);
      }
      /**
       * Get wallet balance.
       */
      async getBalance(provider) {
        const state = await provider.getState();
        return state.balance;
      }
      /**
       * Send signed message.
       */
      async send(provider, message) {
        await provider.external(message);
      }
      /**
       * Sign and send message.
       */
      async sendTransfer(provider, args) {
        const message = this.createTransfer(args);
        await this.send(provider, message);
      }
      /**
       * Create signed message.
       */
      createTransfer(args) {
        let seqno = Math.floor(Math.random() * (1 << 32));
        if (args.seqno !== null && args.seqno !== void 0) {
          seqno = args.seqno;
        }
        let timeout = 5 * 60;
        if (args.timeout !== null && args.timeout !== void 0 && args.timeout < timeout) {
          timeout = args.timeout;
        }
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY | core_1.SendMode.IGNORE_ERRORS;
        if (args.sendMode !== null && args.sendMode !== void 0) {
          sendMode = args.sendMode;
        }
        let now = Date.now();
        if (args.now !== null && args.now !== void 0) {
          now = args.now;
        }
        return (0, core_1.beginCell)().store(storeSignedTransferHighloadWalletV2({
          secretKey: args.secretKey,
          messages: args.messages,
          seqno,
          sendMode,
          timeout,
          walletId: this.walletId,
          now
        })).endCell();
      }
      /**
       * Load signed message.
       */
      loadTransfer(src) {
        return loadSignedTransferHighloadWalletV2(src);
      }
      /**
       * Send signed message and wait for processing.
       */
      async sendTransferAndWait(provider, args, sleepInterval = 3e3) {
        const transfer = this.createTransfer(args);
        const { queryId } = this.loadTransfer(transfer.beginParse());
        while (true) {
          try {
            await provider.external(transfer);
          } catch (e) {
          }
          await (0, utils_1.sleep)(sleepInterval);
          const state = await provider.getState();
          if (state.state.type === "uninit") {
            continue;
          }
          const status = await this.getProcessedStatus(provider, queryId);
          if (status === "processed") {
            return;
          } else if (status === "forgotten") {
            throw new Error("The transfer was forgotten");
          }
        }
      }
      /**
       * Get processed status of message.
       */
      async getProcessedStatus(provider, queryId) {
        const { stack } = await provider.get("processed?", [{ type: "int", value: queryId }]);
        const processedStatus = stack.readBigNumber();
        switch (processedStatus) {
          case -1n:
            return "processed";
          case 0n:
            return "unprocessed";
          case 1n:
            return "forgotten";
          default:
            throw new Error("Unknown processed status " + processedStatus);
        }
      }
      /**
       * Create sender.
       */
      sender(provider, secretKey) {
        return {
          send: async (args) => {
            await this.sendTransferAndWait(provider, {
              secretKey,
              sendMode: args.sendMode,
              messages: [(0, core_1.internal)({
                to: args.to,
                value: args.value,
                bounce: args.bounce,
                init: args.init,
                body: args.body
              })]
            });
          },
          address: this.address
        };
      }
    };
    exports.HighloadWalletContractV2 = HighloadWalletContractV2;
    function createMessageRelaxedValue() {
      return {
        serialize: (args, builder) => {
          const { sendMode, message } = args;
          const messageRelaxed = (0, core_1.beginCell)().storeWritable((0, core_1.storeMessageRelaxed)(message));
          builder.storeUint(sendMode, 8);
          builder.storeRef(messageRelaxed);
        },
        parse: (src) => {
          const sendMode = src.loadUint(8);
          const message = (0, core_1.loadMessageRelaxed)(src.loadRef().beginParse());
          return { sendMode, message };
        }
      };
    }
    function getQueryId(now, timeout, seqno) {
      const validUntil = Math.floor(now / 1e3) + timeout;
      return (BigInt(validUntil) << 32n) + BigInt(seqno);
    }
    function storeSignedTransferHighloadWalletV2(args) {
      return (builder) => {
        const { secretKey, messages, seqno, sendMode, now, timeout, walletId } = args;
        const queryId = getQueryId(now, timeout, seqno);
        const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.Int(16), createMessageRelaxedValue());
        for (const [i, message] of messages.entries()) {
          dict.set(i, { sendMode, message });
        }
        const signedMessage = (0, core_1.beginCell)().storeUint(walletId, 32).storeUint(queryId, 64).storeDict(dict).endCell();
        const hash = signedMessage.hash();
        const signature = (0, crypto_1.sign)(hash, secretKey);
        builder.storeBuffer(signature);
        builder.storeSlice(signedMessage.beginParse());
      };
    }
    function loadSignedTransferHighloadWalletV2(src) {
      const signature = src.loadBuffer(64);
      const walletId = src.loadUint(32);
      const queryId = src.loadUintBig(64);
      const dict = src.loadDict(core_1.Dictionary.Keys.Int(16), createMessageRelaxedValue());
      const messages = dict.values();
      return {
        signature,
        walletId,
        queryId,
        messages
      };
    }
  }
});

// node_modules/@ton-community/assets-sdk/dist/wallets/wallets.js
var require_wallets = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/wallets/wallets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSender = exports.createWallet = exports.createHighloadV2 = void 0;
    var HighloadWalletContractV2_1 = require_HighloadWalletContractV2();
    var ton_client_api_1 = require_ton_client_api();
    var WORKCHAIN = 0;
    function createHighloadV2(publicKey) {
      return HighloadWalletContractV2_1.HighloadWalletContractV2.create({ workchain: WORKCHAIN, publicKey });
    }
    exports.createHighloadV2 = createHighloadV2;
    function createWallet(walletType, publicKey) {
      switch (walletType) {
        case "highload-v2":
          return createHighloadV2(publicKey);
        default:
          throw new Error("Unsupported wallet type");
      }
    }
    exports.createWallet = createWallet;
    async function createSender(walletType, keypair, clientOrNetwork) {
      const isNetwork = clientOrNetwork === "testnet" || clientOrNetwork === "mainnet";
      const client = isNetwork ? await (0, ton_client_api_1.createApi)(clientOrNetwork) : clientOrNetwork;
      const wallet = createWallet(walletType, keypair.publicKey);
      return client.open(wallet).sender(keypair.secretKey);
    }
    exports.createSender = createSender;
  }
});

// node_modules/@ton-community/assets-sdk/dist/error.js
var require_error = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoSenderError = void 0;
    var NoSenderError = class extends Error {
      constructor() {
        super("Sender is not set");
      }
    };
    exports.NoSenderError = NoSenderError;
  }
});

// node_modules/@ton-community/assets-sdk/dist/TonAPI.js
var require_TonAPI = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/TonAPI.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TonAPI = void 0;
    var core_1 = require_dist2();
    var zod_1 = __importDefault(require_lib());
    var axios_1 = __importDefault(require_axios());
    var Address = zod_1.default.string().transform((v) => core_1.Address.parseRaw(v));
    var HexBuffer = zod_1.default.string().transform((v) => Buffer.from(v, "hex"));
    var zBigint = zod_1.default.union([zod_1.default.number(), zod_1.default.string()]).transform((v) => BigInt(v));
    var zStrnum = zod_1.default.union([zod_1.default.number(), zod_1.default.string()]).transform((v) => Number(v));
    var ImagePreview = zod_1.default.object({
      resolution: zod_1.default.string(),
      url: zod_1.default.string()
    });
    var AccountAddress = zod_1.default.object({
      address: Address,
      name: zod_1.default.optional(zod_1.default.string()),
      is_scam: zod_1.default.boolean(),
      icon: zod_1.default.optional(zod_1.default.string()),
      is_wallet: zod_1.default.boolean()
    });
    var NftCollection = zod_1.default.object({
      address: Address,
      next_item_index: zBigint,
      owner: zod_1.default.optional(AccountAddress),
      metadata: zod_1.default.optional(zod_1.default.record(zod_1.default.any())),
      raw_collection_content: HexBuffer,
      previews: zod_1.default.optional(zod_1.default.array(ImagePreview)),
      approved_by: zod_1.default.array(zod_1.default.string())
    });
    var NftCollections = zod_1.default.object({
      nft_collections: zod_1.default.array(NftCollection)
    });
    var Price = zod_1.default.object({
      value: zBigint,
      token_name: zod_1.default.string()
    });
    var Sale = zod_1.default.object({
      address: Address,
      market: AccountAddress,
      owner: zod_1.default.optional(AccountAddress),
      price: Price
    });
    var NftItem = zod_1.default.object({
      address: Address,
      index: zBigint,
      owner: zod_1.default.optional(AccountAddress),
      collection: zod_1.default.optional(zod_1.default.object({
        address: Address,
        name: zod_1.default.string(),
        description: zod_1.default.string()
      })),
      verified: zod_1.default.boolean(),
      metadata: zod_1.default.record(zod_1.default.any()),
      sale: zod_1.default.optional(Sale),
      previews: zod_1.default.optional(zod_1.default.array(ImagePreview)),
      dns: zod_1.default.optional(zod_1.default.string()),
      approved_by: zod_1.default.array(zod_1.default.string())
    });
    var NftItems = zod_1.default.object({
      nft_items: zod_1.default.array(NftItem)
    });
    var JettonVerificationType = zod_1.default.union([zod_1.default.literal("whitelist"), zod_1.default.literal("blacklist"), zod_1.default.literal("none")]);
    var JettonMetadata = zod_1.default.object({
      address: Address,
      name: zod_1.default.string(),
      symbol: zod_1.default.string(),
      decimals: zStrnum,
      image: zod_1.default.optional(zod_1.default.string()),
      description: zod_1.default.optional(zod_1.default.string()),
      social: zod_1.default.optional(zod_1.default.array(zod_1.default.string())),
      websites: zod_1.default.optional(zod_1.default.array(zod_1.default.string())),
      catalogs: zod_1.default.optional(zod_1.default.array(zod_1.default.string()))
    });
    var JettonInfo = zod_1.default.object({
      mintable: zod_1.default.boolean(),
      total_supply: zBigint,
      metadata: JettonMetadata,
      verification: JettonVerificationType,
      holders_count: zod_1.default.number()
    });
    var Jettons = zod_1.default.object({
      jettons: zod_1.default.array(JettonInfo)
    });
    var JettonHolder = zod_1.default.object({
      address: Address,
      owner: AccountAddress,
      balance: zBigint
    });
    var JettonHolders = zod_1.default.object({
      addresses: zod_1.default.array(JettonHolder)
    });
    var EncryptedComment = zod_1.default.object({
      encryption_type: zod_1.default.string(),
      cipher_text: HexBuffer
    });
    var Refund = zod_1.default.object({
      type: zod_1.default.string(),
      origin: Address
    });
    var NftItemTransferAction = zod_1.default.object({
      sender: zod_1.default.optional(AccountAddress),
      recipient: zod_1.default.optional(AccountAddress),
      nft: Address,
      comment: zod_1.default.optional(zod_1.default.string()),
      encrypted_comment: zod_1.default.optional(EncryptedComment),
      payload: zod_1.default.optional(HexBuffer),
      refund: zod_1.default.optional(Refund)
    });
    var ActionStatus = zod_1.default.union([zod_1.default.literal("ok"), zod_1.default.literal("failed")]);
    var ActionSpecificNftItemTransfer = zod_1.default.object({
      type: zod_1.default.literal("NftItemTransfer"),
      status: ActionStatus,
      NftItemTransfer: NftItemTransferAction
    }).transform((v) => ({
      status: v.status,
      ...v.NftItemTransfer
    }));
    var AccountEventGeneric = (t) => zod_1.default.object({
      event_id: zod_1.default.string(),
      account: AccountAddress,
      timestamp: zod_1.default.number(),
      actions: zod_1.default.array(t),
      is_scam: zod_1.default.boolean(),
      lt: zBigint,
      in_progress: zod_1.default.boolean()
    });
    var AccountEventNftItemTransfer = AccountEventGeneric(ActionSpecificNftItemTransfer);
    var AccountEventsGeneric = (t) => zod_1.default.object({
      events: zod_1.default.array(t),
      next_from: zBigint
    });
    var AccountEventsNftItemTransfer = AccountEventsGeneric(AccountEventNftItemTransfer);
    var TokenRates = zod_1.default.object({
      prices: zod_1.default.optional(zod_1.default.record(zod_1.default.number())),
      diff_24h: zod_1.default.optional(zod_1.default.record(zod_1.default.string())),
      diff_7d: zod_1.default.optional(zod_1.default.record(zod_1.default.string())),
      diff_30d: zod_1.default.optional(zod_1.default.record(zod_1.default.string()))
    });
    var JettonPreview = zod_1.default.object({
      address: Address,
      name: zod_1.default.string(),
      symbol: zod_1.default.string(),
      decimals: zStrnum,
      image: zod_1.default.string(),
      verification: JettonVerificationType
    });
    var JettonBalance = zod_1.default.object({
      balance: zBigint,
      price: zod_1.default.optional(TokenRates),
      wallet_address: AccountAddress,
      jetton: JettonPreview
    });
    var JettonBalances = zod_1.default.object({
      balances: zod_1.default.array(JettonBalance)
    });
    var rawAddress = (address) => {
      return typeof address === "string" ? address : address.toRawString();
    };
    var TonAPI = class {
      constructor(params) {
        this.instance = axios_1.default.create({
          baseURL: (params == null ? void 0 : params.baseURL) ?? "https://tonapi.io",
          headers: (params == null ? void 0 : params.token) === void 0 ? {} : {
            "Authorization": "Bearer " + params.token
          }
        });
      }
      async getNftCollections(params) {
        return NftCollections.parse((await this.instance.get("/v2/nfts/collections", {
          params
        })).data).nft_collections;
      }
      async getNftCollection(collection) {
        return NftCollection.parse((await this.instance.get(`/v2/nfts/collections/${rawAddress(collection)}`)).data);
      }
      async getNftCollectionItems(collection, params) {
        return NftItems.parse((await this.instance.get(`/v2/nfts/collections/${rawAddress(collection)}/items`, {
          params
        })).data).nft_items;
      }
      async getNftItems(items) {
        return NftItems.parse((await this.instance.post(`/v2/nfts/_bulk`, {
          account_ids: items.map(rawAddress)
        })).data).nft_items;
      }
      async getNftItem(item) {
        return NftItem.parse((await this.instance.get(`/v2/nfts/${rawAddress(item)}`)).data);
      }
      async getJettons(params) {
        return Jettons.parse((await this.instance.get("/v2/jettons", {
          params
        })).data).jettons;
      }
      async getJetton(jettonMaster) {
        return JettonInfo.parse((await this.instance.get(`/v2/jettons/${rawAddress(jettonMaster)}`)).data);
      }
      async getJettonHolders(jettonMaster, params) {
        return JettonHolders.parse((await this.instance.get(`/v2/jettons/${rawAddress(jettonMaster)}/holders`, {
          params
        })).data).addresses;
      }
      async getNftItemTransferHistory(item, params) {
        return AccountEventsNftItemTransfer.parse((await this.instance.get(`/v2/nfts/${rawAddress(item)}/history`, {
          params: {
            limit: 100,
            ...params
          }
        })).data);
      }
      async getAccountNfts(account, params) {
        return NftItems.parse((await this.instance.get(`/v2/accounts/${rawAddress(account)}/nfts`, {
          params: {
            ...params,
            collection: (params == null ? void 0 : params.collection) === void 0 ? void 0 : rawAddress(params.collection)
          }
        })).data).nft_items;
      }
      async getAccountJettons(account, params) {
        return JettonBalances.parse((await this.instance.get(`/v2/accounts/${rawAddress(account)}/jettons`, {
          params: {
            currencies: (params == null ? void 0 : params.currencies) === void 0 ? void 0 : params.currencies.join(",")
          }
        })).data).balances;
      }
    };
    exports.TonAPI = TonAPI;
  }
});

// node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonExcessesMessage.js
var require_JettonExcessesMessage = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/jetton/types/JettonExcessesMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadJettonExcessesMessage = exports.storeJettonExcessesMessage = void 0;
    var opcodes_1 = require_opcodes();
    function storeJettonExcessesMessage(src) {
      return (builder) => {
        builder.storeUint(opcodes_1.JETTON_EXCESSES_OPCODE, 32);
        builder.storeUint(src.queryId, 64);
      };
    }
    exports.storeJettonExcessesMessage = storeJettonExcessesMessage;
    function loadJettonExcessesMessage(slice) {
      if (slice.loadUint(32) !== opcodes_1.JETTON_EXCESSES_OPCODE) {
        throw new Error("Wrong opcode");
      }
      let queryId = slice.loadUintBig(64);
      return {
        queryId
      };
    }
    exports.loadJettonExcessesMessage = loadJettonExcessesMessage;
  }
});

// node_modules/@ton-community/assets-sdk/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@ton-community/assets-sdk/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeNftGetStaticDataMessage = exports.loadNftGetStaticDataMessage = exports.storeNftExcessesMessage = exports.loadNftExcessesMessage = exports.storeNftDeployMessage = exports.loadNftDeployMessage = exports.loadNftCollectionMessage = exports.storeNftCollectionData = exports.loadNftCollectionData = exports.parseNftCollectionTransaction = exports.storeNftChangeContentMessage = exports.loadNftChangeContentMessage = exports.storeNftChangeAdminMessage = exports.loadNftChangeAdminMessage = exports.storeNftBatchMintMessage = exports.loadNftBatchMintMessage = exports.createNftMintItemValue = exports.storeNftBatchMintItem = exports.loadNftBatchMintItem = exports.NFT_MINT_OPCODE = exports.NFT_CHANGE_CONTENT_OPCODE = exports.NFT_CHANGE_ADMIN_OPCODE = exports.NFT_BATCH_MINT_OPCODE = exports.NFT_OWNER_ASSIGNED_OPCODE = exports.NFT_REPORT_STATIC_DATA_OPCODE = exports.NFT_GET_STATIC_DATA_OPCODE = exports.NFT_EXCESSES_OPCODE = exports.NFT_TRANSFER_OPCODE = exports.TonAPI = exports.NoSenderError = exports.parseTransferTransaction = exports.storeEncryptedMessage = exports.storeTextMessage = exports.storeSimpleTransferMessage = exports.loadEncryptedMessage = exports.loadTextMessage = exports.loadSimpleTransferMessage = exports.loadTransferMessage = exports.ENCRYPTED_MESSAGE_OPCODE = exports.TEXT_OPCODE = exports.HighloadWalletContractV2 = exports.createSender = exports.createHighloadV2 = exports.createWallet = exports.importKey = exports.createApi = exports.NoopStorage = exports.S3Storage = exports.PinataStorage = exports.AssetsSDK = void 0;
    exports.storeJettonChangeContentMessage = exports.loadJettonChangeContentMessage = exports.storeJettonChangeAdminMessage = exports.loadJettonChangeAdminMessage = exports.storeJettonBurnNotificationMessage = exports.loadJettonBurnNotificationMessage = exports.storeJettonBurnMessage = exports.loadJettonBurnMessage = exports.jettonContentToInternal = exports.parseJettonContent = exports.jettonWalletConfigToCell = exports.JettonWallet = exports.jettonMinterConfigToCell = exports.JettonMinter = exports.JETTON_TRANSFER_NOTIFICATION_OPCODE = exports.JETTON_EXCESSES_OPCODE = exports.JETTON_MINT_OPCODE = exports.JETTON_INTERNAL_TRANSFER_OPCODE = exports.JETTON_TRANSFER_OPCODE = exports.JETTON_CHANGE_CONTENT_OPCODE = exports.JETTON_CHANGE_ADMIN_OPCODE = exports.JETTON_BURN_OPCODE = exports.JETTON_BURN_NOTIFICATION_OPCODE = exports.NftSale = exports.nftItemConfigToCell = exports.NftItem = exports.sbtCollectionConfigToCell = exports.SbtCollection = exports.nftCollectionConfigToCell = exports.NftCollection = exports.createSbtItemParamsValue = exports.storeSbtItemParams = exports.loadSbtItemParams = exports.parseSbtItemTransaction = exports.parseSbtCollectionTransaction = exports.storeNftTransferMessage = exports.loadNftTransferMessage = exports.storeNftRoyaltyParams = exports.loadNftRoyaltyParams = exports.storeNftReportStaticDataMessage = exports.loadNftReportStaticDataMessage = exports.storeNftOwnerAssignedMessage = exports.loadNftOwnerAssignedMessage = exports.storeNftMintMessage = exports.loadNftMintMessage = exports.loadNftMessage = exports.createNftItemParamsValue = exports.storeNftItemParams = exports.loadNftItemParams = exports.parseNftItemTransaction = void 0;
    exports.loadJettonWalletMessage = exports.parseJettonWalletTransaction = exports.loadJettonMinterMessage = exports.parseJettonMinterTransaction = exports.storeJettonTransferNotificationMessage = exports.loadJettonTransferNotificationMessage = exports.storeJettonTransferMessage = exports.loadJettonTransferMessage = exports.storeJettonMintMessage = exports.loadJettonMintMessage = exports.storeJettonMinterContent = exports.loadJettonMinterContent = exports.storeJettonInternalTransferMessage = exports.loadJettonInternalTransferMessage = exports.storeJettonExcessesMessage = exports.loadJettonExcessesMessage = void 0;
    var sdk_1 = require_sdk2();
    Object.defineProperty(exports, "AssetsSDK", { enumerable: true, get: function() {
      return sdk_1.AssetsSDK;
    } });
    var pinata_1 = require_pinata();
    Object.defineProperty(exports, "PinataStorage", { enumerable: true, get: function() {
      return pinata_1.PinataStorage;
    } });
    var s3_1 = require_s3();
    Object.defineProperty(exports, "S3Storage", { enumerable: true, get: function() {
      return s3_1.S3Storage;
    } });
    var noop_1 = require_noop();
    Object.defineProperty(exports, "NoopStorage", { enumerable: true, get: function() {
      return noop_1.NoopStorage;
    } });
    var ton_client_api_1 = require_ton_client_api();
    Object.defineProperty(exports, "createApi", { enumerable: true, get: function() {
      return ton_client_api_1.createApi;
    } });
    var key_1 = require_key();
    Object.defineProperty(exports, "importKey", { enumerable: true, get: function() {
      return key_1.importKey;
    } });
    var wallets_1 = require_wallets();
    Object.defineProperty(exports, "createWallet", { enumerable: true, get: function() {
      return wallets_1.createWallet;
    } });
    Object.defineProperty(exports, "createHighloadV2", { enumerable: true, get: function() {
      return wallets_1.createHighloadV2;
    } });
    Object.defineProperty(exports, "createSender", { enumerable: true, get: function() {
      return wallets_1.createSender;
    } });
    var HighloadWalletContractV2_1 = require_HighloadWalletContractV2();
    Object.defineProperty(exports, "HighloadWalletContractV2", { enumerable: true, get: function() {
      return HighloadWalletContractV2_1.HighloadWalletContractV2;
    } });
    var TransferMessage_1 = require_TransferMessage();
    Object.defineProperty(exports, "TEXT_OPCODE", { enumerable: true, get: function() {
      return TransferMessage_1.TEXT_OPCODE;
    } });
    Object.defineProperty(exports, "ENCRYPTED_MESSAGE_OPCODE", { enumerable: true, get: function() {
      return TransferMessage_1.ENCRYPTED_MESSAGE_OPCODE;
    } });
    Object.defineProperty(exports, "loadTransferMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadTransferMessage;
    } });
    Object.defineProperty(exports, "loadSimpleTransferMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadSimpleTransferMessage;
    } });
    Object.defineProperty(exports, "loadTextMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadTextMessage;
    } });
    Object.defineProperty(exports, "loadEncryptedMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadEncryptedMessage;
    } });
    Object.defineProperty(exports, "storeSimpleTransferMessage", { enumerable: true, get: function() {
      return TransferMessage_1.storeSimpleTransferMessage;
    } });
    Object.defineProperty(exports, "storeTextMessage", { enumerable: true, get: function() {
      return TransferMessage_1.storeTextMessage;
    } });
    Object.defineProperty(exports, "storeEncryptedMessage", { enumerable: true, get: function() {
      return TransferMessage_1.storeEncryptedMessage;
    } });
    var TransferAction_1 = require_TransferAction();
    Object.defineProperty(exports, "parseTransferTransaction", { enumerable: true, get: function() {
      return TransferAction_1.parseTransferTransaction;
    } });
    var error_1 = require_error();
    Object.defineProperty(exports, "NoSenderError", { enumerable: true, get: function() {
      return error_1.NoSenderError;
    } });
    var TonAPI_1 = require_TonAPI();
    Object.defineProperty(exports, "TonAPI", { enumerable: true, get: function() {
      return TonAPI_1.TonAPI;
    } });
    var opcodes_1 = require_opcodes2();
    Object.defineProperty(exports, "NFT_TRANSFER_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_TRANSFER_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_EXCESSES_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_EXCESSES_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_GET_STATIC_DATA_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_GET_STATIC_DATA_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_REPORT_STATIC_DATA_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_OWNER_ASSIGNED_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_OWNER_ASSIGNED_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_BATCH_MINT_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_BATCH_MINT_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_CHANGE_ADMIN_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_CHANGE_ADMIN_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_CHANGE_CONTENT_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_CHANGE_CONTENT_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_MINT_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_MINT_OPCODE;
    } });
    var NftBatchMintMessage_1 = require_NftBatchMintMessage();
    Object.defineProperty(exports, "loadNftBatchMintItem", { enumerable: true, get: function() {
      return NftBatchMintMessage_1.loadNftBatchMintItem;
    } });
    var NftBatchMintMessage_2 = require_NftBatchMintMessage();
    Object.defineProperty(exports, "storeNftBatchMintItem", { enumerable: true, get: function() {
      return NftBatchMintMessage_2.storeNftBatchMintItem;
    } });
    var NftBatchMintMessage_3 = require_NftBatchMintMessage();
    Object.defineProperty(exports, "createNftMintItemValue", { enumerable: true, get: function() {
      return NftBatchMintMessage_3.createNftMintItemValue;
    } });
    var NftBatchMintMessage_4 = require_NftBatchMintMessage();
    Object.defineProperty(exports, "loadNftBatchMintMessage", { enumerable: true, get: function() {
      return NftBatchMintMessage_4.loadNftBatchMintMessage;
    } });
    var NftBatchMintMessage_5 = require_NftBatchMintMessage();
    Object.defineProperty(exports, "storeNftBatchMintMessage", { enumerable: true, get: function() {
      return NftBatchMintMessage_5.storeNftBatchMintMessage;
    } });
    var NftChangeAdminMessage_1 = require_NftChangeAdminMessage();
    Object.defineProperty(exports, "loadNftChangeAdminMessage", { enumerable: true, get: function() {
      return NftChangeAdminMessage_1.loadNftChangeAdminMessage;
    } });
    var NftChangeAdminMessage_2 = require_NftChangeAdminMessage();
    Object.defineProperty(exports, "storeNftChangeAdminMessage", { enumerable: true, get: function() {
      return NftChangeAdminMessage_2.storeNftChangeAdminMessage;
    } });
    var NftChangeContentMessage_1 = require_NftChangeContentMessage();
    Object.defineProperty(exports, "loadNftChangeContentMessage", { enumerable: true, get: function() {
      return NftChangeContentMessage_1.loadNftChangeContentMessage;
    } });
    var NftChangeContentMessage_2 = require_NftChangeContentMessage();
    Object.defineProperty(exports, "storeNftChangeContentMessage", { enumerable: true, get: function() {
      return NftChangeContentMessage_2.storeNftChangeContentMessage;
    } });
    var NftCollectionAction_1 = require_NftCollectionAction();
    Object.defineProperty(exports, "parseNftCollectionTransaction", { enumerable: true, get: function() {
      return NftCollectionAction_1.parseNftCollectionTransaction;
    } });
    var NftCollectionData_1 = require_NftCollectionData();
    Object.defineProperty(exports, "loadNftCollectionData", { enumerable: true, get: function() {
      return NftCollectionData_1.loadNftCollectionData;
    } });
    var NftCollectionData_2 = require_NftCollectionData();
    Object.defineProperty(exports, "storeNftCollectionData", { enumerable: true, get: function() {
      return NftCollectionData_2.storeNftCollectionData;
    } });
    var NftCollectionMessage_1 = require_NftCollectionMessage();
    Object.defineProperty(exports, "loadNftCollectionMessage", { enumerable: true, get: function() {
      return NftCollectionMessage_1.loadNftCollectionMessage;
    } });
    var NftDeployMessage_1 = require_NftDeployMessage();
    Object.defineProperty(exports, "loadNftDeployMessage", { enumerable: true, get: function() {
      return NftDeployMessage_1.loadNftDeployMessage;
    } });
    var NftDeployMessage_2 = require_NftDeployMessage();
    Object.defineProperty(exports, "storeNftDeployMessage", { enumerable: true, get: function() {
      return NftDeployMessage_2.storeNftDeployMessage;
    } });
    var NftExcessesMessage_1 = require_NftExcessesMessage();
    Object.defineProperty(exports, "loadNftExcessesMessage", { enumerable: true, get: function() {
      return NftExcessesMessage_1.loadNftExcessesMessage;
    } });
    var NftExcessesMessage_2 = require_NftExcessesMessage();
    Object.defineProperty(exports, "storeNftExcessesMessage", { enumerable: true, get: function() {
      return NftExcessesMessage_2.storeNftExcessesMessage;
    } });
    var NftGetStaticDataMessage_1 = require_NftGetStaticDataMessage();
    Object.defineProperty(exports, "loadNftGetStaticDataMessage", { enumerable: true, get: function() {
      return NftGetStaticDataMessage_1.loadNftGetStaticDataMessage;
    } });
    var NftGetStaticDataMessage_2 = require_NftGetStaticDataMessage();
    Object.defineProperty(exports, "storeNftGetStaticDataMessage", { enumerable: true, get: function() {
      return NftGetStaticDataMessage_2.storeNftGetStaticDataMessage;
    } });
    var NftItemAction_1 = require_NftItemAction();
    Object.defineProperty(exports, "parseNftItemTransaction", { enumerable: true, get: function() {
      return NftItemAction_1.parseNftItemTransaction;
    } });
    var NftItemParams_1 = require_NftItemParams();
    Object.defineProperty(exports, "loadNftItemParams", { enumerable: true, get: function() {
      return NftItemParams_1.loadNftItemParams;
    } });
    var NftItemParams_2 = require_NftItemParams();
    Object.defineProperty(exports, "storeNftItemParams", { enumerable: true, get: function() {
      return NftItemParams_2.storeNftItemParams;
    } });
    var NftItemParams_3 = require_NftItemParams();
    Object.defineProperty(exports, "createNftItemParamsValue", { enumerable: true, get: function() {
      return NftItemParams_3.createNftItemParamsValue;
    } });
    var NftMessage_1 = require_NftMessage();
    Object.defineProperty(exports, "loadNftMessage", { enumerable: true, get: function() {
      return NftMessage_1.loadNftMessage;
    } });
    var NftMintMessage_1 = require_NftMintMessage();
    Object.defineProperty(exports, "loadNftMintMessage", { enumerable: true, get: function() {
      return NftMintMessage_1.loadNftMintMessage;
    } });
    var NftMintMessage_2 = require_NftMintMessage();
    Object.defineProperty(exports, "storeNftMintMessage", { enumerable: true, get: function() {
      return NftMintMessage_2.storeNftMintMessage;
    } });
    var NftOwnerAssignedMessage_1 = require_NftOwnerAssignedMessage();
    Object.defineProperty(exports, "loadNftOwnerAssignedMessage", { enumerable: true, get: function() {
      return NftOwnerAssignedMessage_1.loadNftOwnerAssignedMessage;
    } });
    var NftOwnerAssignedMessage_2 = require_NftOwnerAssignedMessage();
    Object.defineProperty(exports, "storeNftOwnerAssignedMessage", { enumerable: true, get: function() {
      return NftOwnerAssignedMessage_2.storeNftOwnerAssignedMessage;
    } });
    var NftReportStaticDataMessage_1 = require_NftReportStaticDataMessage();
    Object.defineProperty(exports, "loadNftReportStaticDataMessage", { enumerable: true, get: function() {
      return NftReportStaticDataMessage_1.loadNftReportStaticDataMessage;
    } });
    var NftReportStaticDataMessage_2 = require_NftReportStaticDataMessage();
    Object.defineProperty(exports, "storeNftReportStaticDataMessage", { enumerable: true, get: function() {
      return NftReportStaticDataMessage_2.storeNftReportStaticDataMessage;
    } });
    var NftRoyaltyParams_1 = require_NftRoyaltyParams();
    Object.defineProperty(exports, "loadNftRoyaltyParams", { enumerable: true, get: function() {
      return NftRoyaltyParams_1.loadNftRoyaltyParams;
    } });
    var NftRoyaltyParams_2 = require_NftRoyaltyParams();
    Object.defineProperty(exports, "storeNftRoyaltyParams", { enumerable: true, get: function() {
      return NftRoyaltyParams_2.storeNftRoyaltyParams;
    } });
    var NftTransferMessage_1 = require_NftTransferMessage();
    Object.defineProperty(exports, "loadNftTransferMessage", { enumerable: true, get: function() {
      return NftTransferMessage_1.loadNftTransferMessage;
    } });
    var NftTransferMessage_2 = require_NftTransferMessage();
    Object.defineProperty(exports, "storeNftTransferMessage", { enumerable: true, get: function() {
      return NftTransferMessage_2.storeNftTransferMessage;
    } });
    var SbtCollectionAction_1 = require_SbtCollectionAction();
    Object.defineProperty(exports, "parseSbtCollectionTransaction", { enumerable: true, get: function() {
      return SbtCollectionAction_1.parseSbtCollectionTransaction;
    } });
    var SbtItemAction_1 = require_SbtItemAction();
    Object.defineProperty(exports, "parseSbtItemTransaction", { enumerable: true, get: function() {
      return SbtItemAction_1.parseSbtItemTransaction;
    } });
    var SbtItemParams_1 = require_SbtItemParams();
    Object.defineProperty(exports, "loadSbtItemParams", { enumerable: true, get: function() {
      return SbtItemParams_1.loadSbtItemParams;
    } });
    var SbtItemParams_2 = require_SbtItemParams();
    Object.defineProperty(exports, "storeSbtItemParams", { enumerable: true, get: function() {
      return SbtItemParams_2.storeSbtItemParams;
    } });
    var SbtItemParams_3 = require_SbtItemParams();
    Object.defineProperty(exports, "createSbtItemParamsValue", { enumerable: true, get: function() {
      return SbtItemParams_3.createSbtItemParamsValue;
    } });
    var NftCollection_1 = require_NftCollection();
    Object.defineProperty(exports, "NftCollection", { enumerable: true, get: function() {
      return NftCollection_1.NftCollection;
    } });
    Object.defineProperty(exports, "nftCollectionConfigToCell", { enumerable: true, get: function() {
      return NftCollection_1.nftCollectionConfigToCell;
    } });
    var SbtCollection_1 = require_SbtCollection();
    Object.defineProperty(exports, "SbtCollection", { enumerable: true, get: function() {
      return SbtCollection_1.SbtCollection;
    } });
    Object.defineProperty(exports, "sbtCollectionConfigToCell", { enumerable: true, get: function() {
      return SbtCollection_1.sbtCollectionConfigToCell;
    } });
    var NftItem_1 = require_NftItem();
    Object.defineProperty(exports, "NftItem", { enumerable: true, get: function() {
      return NftItem_1.NftItem;
    } });
    Object.defineProperty(exports, "nftItemConfigToCell", { enumerable: true, get: function() {
      return NftItem_1.nftItemConfigToCell;
    } });
    var NftSale_1 = require_NftSale();
    Object.defineProperty(exports, "NftSale", { enumerable: true, get: function() {
      return NftSale_1.NftSale;
    } });
    var opcodes_2 = require_opcodes();
    Object.defineProperty(exports, "JETTON_BURN_NOTIFICATION_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_BURN_NOTIFICATION_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_BURN_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_BURN_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_CHANGE_ADMIN_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_CHANGE_ADMIN_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_CHANGE_CONTENT_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_CHANGE_CONTENT_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_TRANSFER_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_TRANSFER_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_INTERNAL_TRANSFER_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_INTERNAL_TRANSFER_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_MINT_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_MINT_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_EXCESSES_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_EXCESSES_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_TRANSFER_NOTIFICATION_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_TRANSFER_NOTIFICATION_OPCODE;
    } });
    var JettonMinter_1 = require_JettonMinter();
    Object.defineProperty(exports, "JettonMinter", { enumerable: true, get: function() {
      return JettonMinter_1.JettonMinter;
    } });
    Object.defineProperty(exports, "jettonMinterConfigToCell", { enumerable: true, get: function() {
      return JettonMinter_1.jettonMinterConfigToCell;
    } });
    var JettonWallet_1 = require_JettonWallet();
    Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function() {
      return JettonWallet_1.JettonWallet;
    } });
    Object.defineProperty(exports, "jettonWalletConfigToCell", { enumerable: true, get: function() {
      return JettonWallet_1.jettonWalletConfigToCell;
    } });
    var content_1 = require_content2();
    Object.defineProperty(exports, "parseJettonContent", { enumerable: true, get: function() {
      return content_1.parseJettonContent;
    } });
    Object.defineProperty(exports, "jettonContentToInternal", { enumerable: true, get: function() {
      return content_1.jettonContentToInternal;
    } });
    var JettonBurnMessage_1 = require_JettonBurnMessage();
    Object.defineProperty(exports, "loadJettonBurnMessage", { enumerable: true, get: function() {
      return JettonBurnMessage_1.loadJettonBurnMessage;
    } });
    var JettonBurnMessage_2 = require_JettonBurnMessage();
    Object.defineProperty(exports, "storeJettonBurnMessage", { enumerable: true, get: function() {
      return JettonBurnMessage_2.storeJettonBurnMessage;
    } });
    var JettonBurnNotificationMessage_1 = require_JettonBurnNotificationMessage();
    Object.defineProperty(exports, "loadJettonBurnNotificationMessage", { enumerable: true, get: function() {
      return JettonBurnNotificationMessage_1.loadJettonBurnNotificationMessage;
    } });
    var JettonBurnNotificationMessage_2 = require_JettonBurnNotificationMessage();
    Object.defineProperty(exports, "storeJettonBurnNotificationMessage", { enumerable: true, get: function() {
      return JettonBurnNotificationMessage_2.storeJettonBurnNotificationMessage;
    } });
    var JettonChangeAdminMessage_1 = require_JettonChangeAdminMessage();
    Object.defineProperty(exports, "loadJettonChangeAdminMessage", { enumerable: true, get: function() {
      return JettonChangeAdminMessage_1.loadJettonChangeAdminMessage;
    } });
    var JettonChangeAdminMessage_2 = require_JettonChangeAdminMessage();
    Object.defineProperty(exports, "storeJettonChangeAdminMessage", { enumerable: true, get: function() {
      return JettonChangeAdminMessage_2.storeJettonChangeAdminMessage;
    } });
    var JettonChangeContentMessage_1 = require_JettonChangeContentMessage();
    Object.defineProperty(exports, "loadJettonChangeContentMessage", { enumerable: true, get: function() {
      return JettonChangeContentMessage_1.loadJettonChangeContentMessage;
    } });
    var JettonChangeContentMessage_2 = require_JettonChangeContentMessage();
    Object.defineProperty(exports, "storeJettonChangeContentMessage", { enumerable: true, get: function() {
      return JettonChangeContentMessage_2.storeJettonChangeContentMessage;
    } });
    var JettonExcessesMessage_1 = require_JettonExcessesMessage();
    Object.defineProperty(exports, "loadJettonExcessesMessage", { enumerable: true, get: function() {
      return JettonExcessesMessage_1.loadJettonExcessesMessage;
    } });
    var JettonExcessesMessage_2 = require_JettonExcessesMessage();
    Object.defineProperty(exports, "storeJettonExcessesMessage", { enumerable: true, get: function() {
      return JettonExcessesMessage_2.storeJettonExcessesMessage;
    } });
    var JettonInternalTransferMessage_1 = require_JettonInternalTransferMessage();
    Object.defineProperty(exports, "loadJettonInternalTransferMessage", { enumerable: true, get: function() {
      return JettonInternalTransferMessage_1.loadJettonInternalTransferMessage;
    } });
    var JettonInternalTransferMessage_2 = require_JettonInternalTransferMessage();
    Object.defineProperty(exports, "storeJettonInternalTransferMessage", { enumerable: true, get: function() {
      return JettonInternalTransferMessage_2.storeJettonInternalTransferMessage;
    } });
    var JettonMinterContent_1 = require_JettonMinterContent();
    Object.defineProperty(exports, "loadJettonMinterContent", { enumerable: true, get: function() {
      return JettonMinterContent_1.loadJettonMinterContent;
    } });
    var JettonMinterContent_2 = require_JettonMinterContent();
    Object.defineProperty(exports, "storeJettonMinterContent", { enumerable: true, get: function() {
      return JettonMinterContent_2.storeJettonMinterContent;
    } });
    var JettonMintMessage_1 = require_JettonMintMessage();
    Object.defineProperty(exports, "loadJettonMintMessage", { enumerable: true, get: function() {
      return JettonMintMessage_1.loadJettonMintMessage;
    } });
    var JettonMintMessage_2 = require_JettonMintMessage();
    Object.defineProperty(exports, "storeJettonMintMessage", { enumerable: true, get: function() {
      return JettonMintMessage_2.storeJettonMintMessage;
    } });
    var JettonTransferMessage_1 = require_JettonTransferMessage();
    Object.defineProperty(exports, "loadJettonTransferMessage", { enumerable: true, get: function() {
      return JettonTransferMessage_1.loadJettonTransferMessage;
    } });
    var JettonTransferMessage_2 = require_JettonTransferMessage();
    Object.defineProperty(exports, "storeJettonTransferMessage", { enumerable: true, get: function() {
      return JettonTransferMessage_2.storeJettonTransferMessage;
    } });
    var JettonTransferNotificationMessage_1 = require_JettonTransferNotificationMessage();
    Object.defineProperty(exports, "loadJettonTransferNotificationMessage", { enumerable: true, get: function() {
      return JettonTransferNotificationMessage_1.loadJettonTransferNotificationMessage;
    } });
    var JettonTransferNotificationMessage_2 = require_JettonTransferNotificationMessage();
    Object.defineProperty(exports, "storeJettonTransferNotificationMessage", { enumerable: true, get: function() {
      return JettonTransferNotificationMessage_2.storeJettonTransferNotificationMessage;
    } });
    var JettonMinterAction_1 = require_JettonMinterAction();
    Object.defineProperty(exports, "parseJettonMinterTransaction", { enumerable: true, get: function() {
      return JettonMinterAction_1.parseJettonMinterTransaction;
    } });
    var JettonMinterMessage_1 = require_JettonMinterMessage();
    Object.defineProperty(exports, "loadJettonMinterMessage", { enumerable: true, get: function() {
      return JettonMinterMessage_1.loadJettonMinterMessage;
    } });
    var JettonWalletAction_1 = require_JettonWalletAction();
    Object.defineProperty(exports, "parseJettonWalletTransaction", { enumerable: true, get: function() {
      return JettonWalletAction_1.parseJettonWalletTransaction;
    } });
    var JettonWalletMessage_1 = require_JettonWalletMessage();
    Object.defineProperty(exports, "loadJettonWalletMessage", { enumerable: true, get: function() {
      return JettonWalletMessage_1.loadJettonWalletMessage;
    } });
  }
});
export default require_dist4();
//# sourceMappingURL=@ton-community_assets-sdk.js.map
