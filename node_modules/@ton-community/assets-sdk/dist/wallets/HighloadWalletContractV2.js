"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighloadWalletContractV2 = void 0;
const core_1 = require("@ton/core");
const crypto_1 = require("@ton/crypto");
const utils_1 = require("../utils");
class HighloadWalletContractV2 {
    constructor(workchain, publicKey, walletId) {
        this.workchain = workchain;
        this.publicKey = publicKey;
        if (walletId !== null && walletId !== undefined) {
            this.walletId = walletId;
        }
        else {
            this.walletId = 698983191 + workchain;
        }
        // Reference: https://github.com/ton-blockchain/ton/blob/master/crypto/smartcont/highload-wallet-v2-code.fc
        const code = core_1.Cell.fromBase64('te6cckEBCQEA5QABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQHq8oMI1xgg0x/TP/gjqh9TILnyY+1E0NMf0z/T//QE0VNggED0Dm+hMfJgUXO68qIH+QFUEIf5EPKjAvQE0fgAf44WIYAQ9HhvpSCYAtMH1DAB+wCRMuIBs+ZbgyWhyEA0gED0Q4rmMQHIyx8Tyz/L//QAye1UCAAE0DACASAGBwAXvZznaiaGmvmOuF/8AEG+X5dqJoaY+Y6Z/p/5j6AmipEEAgegc30JjJLb/JXdHxQANCCAQPSWb6VsEiCUMFMDud4gkzM2AZJsIeKzn55UWg==');
        const data = (0, core_1.beginCell)()
            .storeUint(this.walletId, 32)
            .storeUint(0, 64)
            .storeBuffer(this.publicKey, 32)
            .storeDict(null)
            .endCell();
        this.init = { code, data };
        this.address = (0, core_1.contractAddress)(this.workchain, this.init);
    }
    static create(args) {
        return new HighloadWalletContractV2(args.workchain, args.publicKey, args.walletId);
    }
    /**
     * Get wallet balance.
     */
    async getBalance(provider) {
        const state = await provider.getState();
        return state.balance;
    }
    /**
     * Send signed message.
     */
    async send(provider, message) {
        await provider.external(message);
    }
    /**
     * Sign and send message.
     */
    async sendTransfer(provider, args) {
        const message = this.createTransfer(args);
        await this.send(provider, message);
    }
    /**
     * Create signed message.
     */
    createTransfer(args) {
        let seqno = Math.floor(Math.random() * (1 << 32));
        if (args.seqno !== null && args.seqno !== undefined) {
            seqno = args.seqno;
        }
        let timeout = 5 * 60; // 15 minutes
        if (args.timeout !== null && args.timeout !== undefined && args.timeout < timeout) {
            timeout = args.timeout;
        }
        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY | core_1.SendMode.IGNORE_ERRORS;
        if (args.sendMode !== null && args.sendMode !== undefined) {
            sendMode = args.sendMode;
        }
        let now = Date.now();
        if (args.now !== null && args.now !== undefined) {
            now = args.now;
        }
        return (0, core_1.beginCell)().store(storeSignedTransferHighloadWalletV2({
            secretKey: args.secretKey,
            messages: args.messages,
            seqno: seqno,
            sendMode: sendMode,
            timeout: timeout,
            walletId: this.walletId,
            now: now,
        })).endCell();
    }
    /**
     * Load signed message.
     */
    loadTransfer(src) {
        return loadSignedTransferHighloadWalletV2(src);
    }
    /**
     * Send signed message and wait for processing.
     */
    async sendTransferAndWait(provider, args, sleepInterval = 3000) {
        const transfer = this.createTransfer(args);
        const { queryId } = this.loadTransfer(transfer.beginParse());
        while (true) {
            try {
                await provider.external(transfer);
            }
            catch (e) {
            }
            await (0, utils_1.sleep)(sleepInterval);
            const state = await provider.getState();
            if (state.state.type === 'uninit') {
                continue;
            }
            const status = await this.getProcessedStatus(provider, queryId);
            if (status === 'processed') {
                return;
            }
            else if (status === 'forgotten') {
                throw new Error('The transfer was forgotten');
            }
        }
    }
    /**
     * Get processed status of message.
     */
    async getProcessedStatus(provider, queryId) {
        const { stack } = await provider.get('processed?', [{ type: 'int', value: queryId }]);
        const processedStatus = stack.readBigNumber();
        switch (processedStatus) {
            case -1n:
                return 'processed';
            case 0n:
                return 'unprocessed';
            case 1n:
                return 'forgotten';
            default:
                throw new Error('Unknown processed status ' + processedStatus);
        }
    }
    /**
     * Create sender.
     */
    sender(provider, secretKey) {
        return {
            send: async (args) => {
                await this.sendTransferAndWait(provider, {
                    secretKey: secretKey,
                    sendMode: args.sendMode,
                    messages: [(0, core_1.internal)({
                            to: args.to,
                            value: args.value,
                            bounce: args.bounce,
                            init: args.init,
                            body: args.body,
                        })],
                });
            },
            address: this.address,
        };
    }
}
exports.HighloadWalletContractV2 = HighloadWalletContractV2;
function createMessageRelaxedValue() {
    return {
        serialize: (args, builder) => {
            const { sendMode, message } = args;
            const messageRelaxed = (0, core_1.beginCell)().storeWritable((0, core_1.storeMessageRelaxed)(message));
            builder.storeUint(sendMode, 8);
            builder.storeRef(messageRelaxed);
        },
        parse: (src) => {
            const sendMode = src.loadUint(8);
            const message = (0, core_1.loadMessageRelaxed)(src.loadRef().beginParse());
            return { sendMode, message };
        },
    };
}
function getQueryId(now, timeout, seqno) {
    const validUntil = Math.floor(now / 1000) + timeout;
    return (BigInt(validUntil) << 32n) + BigInt(seqno);
}
function storeSignedTransferHighloadWalletV2(args) {
    return (builder) => {
        const { secretKey, messages, seqno, sendMode, now, timeout, walletId } = args;
        const queryId = getQueryId(now, timeout, seqno);
        const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.Int(16), createMessageRelaxedValue());
        for (const [i, message] of messages.entries()) {
            dict.set(i, { sendMode, message });
        }
        const signedMessage = (0, core_1.beginCell)()
            .storeUint(walletId, 32)
            .storeUint(queryId, 64)
            .storeDict(dict)
            .endCell();
        const hash = signedMessage.hash();
        const signature = (0, crypto_1.sign)(hash, secretKey);
        builder.storeBuffer(signature);
        builder.storeSlice(signedMessage.beginParse());
    };
}
function loadSignedTransferHighloadWalletV2(src) {
    const signature = src.loadBuffer(64);
    const walletId = src.loadUint(32);
    const queryId = src.loadUintBig(64);
    const dict = src.loadDict(core_1.Dictionary.Keys.Int(16), createMessageRelaxedValue());
    const messages = dict.values();
    return {
        signature: signature,
        walletId: walletId,
        queryId: queryId,
        messages: messages,
    };
}
