"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadNftMessage = void 0;
const NftDeployMessage_1 = require("./NftDeployMessage");
const NftTransferMessage_1 = require("./NftTransferMessage");
const NftGetStaticDataMessage_1 = require("./NftGetStaticDataMessage");
const NftReportStaticDataMessage_1 = require("./NftReportStaticDataMessage");
const NftOwnerAssignedMessage_1 = require("./NftOwnerAssignedMessage");
const opcodes_1 = require("../opcodes");
const NftExcessesMessage_1 = require("./NftExcessesMessage");
function loadNftMessage(slice) {
    try {
        const opcode = slice.preloadUint(32);
        switch (opcode) {
            case opcodes_1.NFT_TRANSFER_OPCODE:
                return { kind: 'nft_transfer', ...(0, NftTransferMessage_1.loadNftTransferMessage)(slice) };
            case opcodes_1.NFT_OWNER_ASSIGNED_OPCODE:
                return { kind: 'owner_assigned', ...(0, NftOwnerAssignedMessage_1.loadNftOwnerAssignedMessage)(slice) };
            case opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE:
                return { kind: 'report_static_data', ...(0, NftReportStaticDataMessage_1.loadNftReportStaticDataMessage)(slice) };
            case opcodes_1.NFT_GET_STATIC_DATA_OPCODE:
                return { kind: 'get_static_data', ...(0, NftGetStaticDataMessage_1.loadNftGetStaticDataMessage)(slice) };
            case opcodes_1.NFT_EXCESSES_OPCODE:
                return { kind: 'excesses', ...(0, NftExcessesMessage_1.loadNftExcessesMessage)(slice) };
        }
        if (slice.remainingBits === (256 + 11) && slice.remainingRefs === 1) {
            return { kind: 'nft_deploy', ...(0, NftDeployMessage_1.loadNftDeployMessage)(slice) };
        }
    }
    catch (e) {
    }
    return { kind: 'unknown' };
}
exports.loadNftMessage = loadNftMessage;
