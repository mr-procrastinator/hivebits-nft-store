"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SbtItem = exports.sbtItemConfigToCell = void 0;
const core_1 = require("@ton/core");
const content_1 = require("../content");
const NftCollection_1 = require("./NftCollection");
const content_2 = require("./content");
const sbt_item_1 = require("./contracts/build/sbt-item");
const SbtItemParams_1 = require("./types/SbtItemParams");
const SbtItemAction_1 = require("./types/SbtItemAction");
function sbtItemConfigToCell(config) {
    return (0, core_1.beginCell)()
        .storeUint(config.index, 64)
        .storeAddress(config.collection)
        .endCell();
}
exports.sbtItemConfigToCell = sbtItemConfigToCell;
class SbtItem {
    constructor(address, init, contentResolver) {
        this.address = address;
        this.init = init;
        this.contentResolver = contentResolver;
    }
    static createFromConfig(config, code, workchain, contentResolver) {
        const data = sbtItemConfigToCell(config);
        const init = { data, code: code ?? SbtItem.sbtCode };
        return new SbtItem((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
    }
    static createFromAddress(address, contentResolver) {
        return new SbtItem(address, undefined, contentResolver);
    }
    async sendDeploy(provider, sender, params, value) {
        await provider.internal(sender, {
            value: value ?? (0, core_1.toNano)('0.03'),
            bounce: true,
            body: (0, core_1.beginCell)().store((0, SbtItemParams_1.storeSbtItemParams)(params)).endCell(),
        });
    }
    async getData(provider) {
        const { stack } = await provider.get('get_nft_data', []);
        return {
            initialized: stack.readBoolean(),
            index: stack.readBigNumber(),
            collection: stack.readAddressOpt(),
            owner: stack.readAddressOpt(),
            individualContent: stack.readCellOpt(),
        };
    }
    async getContent(provider) {
        if (this.contentResolver === undefined) {
            throw new Error('No content resolver');
        }
        const { collection, individualContent, index } = await this.getData(provider);
        if (individualContent === null) {
            throw new Error('Individual content is null');
        }
        let content;
        if (collection === null) {
            content = individualContent;
        }
        else {
            const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
            content = await collectionContract.getItemContent(index, individualContent);
        }
        return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(content, this.contentResolver));
    }
    async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
            const state = await provider.getState();
            if (!state.last) {
                return [];
            }
            lt = state.last.lt;
            hash = state.last.hash;
        }
        const transactions = await provider.getTransactions(this.address, lt, hash, limit);
        return transactions.map(tx => (0, SbtItemAction_1.parseSbtItemTransaction)(tx));
    }
}
exports.SbtItem = SbtItem;
SbtItem.sbtCode = core_1.Cell.fromBase64(sbt_item_1.sbtItemCode.codeBoc);
