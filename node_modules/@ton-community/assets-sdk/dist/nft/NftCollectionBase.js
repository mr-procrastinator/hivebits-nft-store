"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NftCollectionBase = void 0;
const core_1 = require("@ton/core");
const content_1 = require("../content");
const content_2 = require("./content");
const nft_collection_editable_1 = require("./contracts/build/nft-collection-editable");
const NftChangeContentMessage_1 = require("./types/NftChangeContentMessage");
const NftMintMessage_1 = require("./types/NftMintMessage");
const NftBatchMintMessage_1 = require("./types/NftBatchMintMessage");
const NftChangeAdminMessage_1 = require("./types/NftChangeAdminMessage");
class NftCollectionBase {
    constructor(address, init, contentResolver, nftItemParamsValue) {
        this.address = address;
        this.init = init;
        this.contentResolver = contentResolver;
        this.itemParamsValue = nftItemParamsValue;
    }
    async sendDeploy(provider, sender, value) {
        await provider.internal(sender, {
            value: value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
        });
    }
    async sendMint(provider, sender, item, options) {
        if (this.itemParamsValue === undefined) {
            throw new Error('No item params value');
        }
        await provider.internal(sender, {
            value: options?.value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
            sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
            body: (0, core_1.beginCell)().store((0, NftMintMessage_1.storeNftMintMessage)({
                queryId: options?.queryId ?? 0n,
                itemIndex: item.index,
                itemParams: item,
                value: item.value ?? (0, core_1.toNano)('0.03'),
            }, this.itemParamsValue.store)).endCell(),
        });
    }
    async sendBatchMint(provider, sender, items, options) {
        if (this.itemParamsValue === undefined) {
            throw new Error('No item params value');
        }
        await provider.internal(sender, {
            value: options?.value ?? (0, core_1.toNano)('0.05') * BigInt(items.length),
            bounce: true,
            body: (0, core_1.beginCell)().store((0, NftBatchMintMessage_1.storeNftBatchMintMessage)({
                queryId: options?.queryId ?? 0n,
                requests: items.map((item) => ({
                    index: item.index,
                    params: item,
                    value: item.value ?? (0, core_1.toNano)('0.03'),
                })),
            }, this.itemParamsValue.store)).endCell(),
        });
    }
    async sendChangeAdmin(provider, sender, newAdmin, options) {
        await provider.internal(sender, {
            value: options?.value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
            body: (0, core_1.beginCell)().store((0, NftChangeAdminMessage_1.storeNftChangeAdminMessage)({
                newAdmin: newAdmin,
                queryId: options?.queryId ?? 0n,
            })).endCell(),
        });
    }
    async sendChangeContent(provider, sender, message, options) {
        await provider.internal(sender, {
            value: options?.value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
            body: (0, core_1.beginCell)().store((0, NftChangeContentMessage_1.storeNftChangeContentMessage)({
                queryId: options?.queryId ?? 0n,
                newContent: message.newContent,
                newRoyaltyParams: message.newRoyaltyParams,
            })).endCell(),
        });
    }
    async getItemAddress(provider, index) {
        const ret = await provider.get('get_nft_address_by_index', [{ type: 'int', value: index }]);
        return ret.stack.readAddress();
    }
    async getData(provider) {
        const ret = await provider.get('get_collection_data', []);
        return {
            nextItemIndex: ret.stack.readBigNumber(),
            content: ret.stack.readCell(),
            owner: ret.stack.readAddressOpt(),
        };
    }
    async getContent(provider) {
        if (this.contentResolver === undefined) {
            throw new Error('No content resolver');
        }
        const data = await this.getData(provider);
        return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(data.content, this.contentResolver));
    }
    async getItemContent(provider, index, individualContent) {
        const res = await provider.get('get_nft_content', [{
                type: 'int',
                value: index,
            }, {
                type: 'cell',
                cell: individualContent,
            }]);
        return res.stack.readCell();
    }
}
exports.NftCollectionBase = NftCollectionBase;
NftCollectionBase.code = core_1.Cell.fromBase64(nft_collection_editable_1.nftCollectionEditableCode.codeBoc);
