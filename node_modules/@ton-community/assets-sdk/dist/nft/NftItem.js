"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NftItem = exports.nftItemConfigToCell = void 0;
const core_1 = require("@ton/core");
const content_1 = require("../content");
const NftCollection_1 = require("./NftCollection");
const content_2 = require("./content");
const nft_item_1 = require("./contracts/build/nft-item");
const types_1 = require("../common/types");
const NftItemParams_1 = require("./types/NftItemParams");
const NftTransferMessage_1 = require("./types/NftTransferMessage");
const NftItemAction_1 = require("./types/NftItemAction");
function nftItemConfigToCell(config) {
    return (0, core_1.beginCell)()
        .storeUint(config.index, 64)
        .storeAddress(config.collection)
        .endCell();
}
exports.nftItemConfigToCell = nftItemConfigToCell;
class NftItem {
    constructor(address, init, contentResolver) {
        this.address = address;
        this.init = init;
        this.contentResolver = contentResolver;
    }
    static createFromConfig(config, code, workchain, contentResolver) {
        const data = nftItemConfigToCell(config);
        const init = { data, code: code ?? NftItem.nftCode };
        return new NftItem((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
    }
    static createFromAddress(address, contentResolver) {
        return new NftItem(address, undefined, contentResolver);
    }
    async sendDeploy(provider, sender, params, value) {
        await provider.internal(sender, {
            value: value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
            body: (0, core_1.beginCell)().store((0, NftItemParams_1.storeNftItemParams)(params)).endCell(),
        });
    }
    async send(provider, sender, newOwner, options) {
        const notification = (0, types_1.parseNotifyOptions)(options?.notify);
        const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
        await provider.internal(sender, {
            value: (options?.value ?? (0, core_1.toNano)('0.05')) + (notification?.amount ?? 0n),
            bounce: true,
            sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
            body: (0, core_1.beginCell)().store((0, NftTransferMessage_1.storeNftTransferMessage)({
                queryId: options?.queryId ?? 0n,
                newOwner: newOwner,
                responseDestination: excessReturn?.address ?? null,
                customPayload: options?.customPayload ?? null,
                forwardAmount: notification?.amount ?? 0n,
                forwardPayload: notification?.payload ?? null,
            })).endCell()
        });
    }
    async getData(provider) {
        const { stack } = await provider.get('get_nft_data', []);
        return {
            initialized: stack.readBoolean(),
            index: stack.readBigNumber(),
            collection: stack.readAddressOpt(),
            owner: stack.readAddressOpt(),
            individualContent: stack.readCellOpt(),
        };
    }
    async getContent(provider) {
        if (this.contentResolver === undefined) {
            throw new Error('No content resolver');
        }
        const { collection, individualContent, index } = await this.getData(provider);
        if (individualContent === null) {
            throw new Error('Individual content is null');
        }
        let content;
        if (collection === null) {
            content = individualContent;
        }
        else {
            const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
            content = await collectionContract.getItemContent(index, individualContent);
        }
        return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(content, this.contentResolver));
    }
    async getRoyaltyParams(provider) {
        const { collection } = await this.getData(provider);
        if (collection === null) {
            // it's means that royalty stored in nft item
            return this.getNftItemRoyaltyParams(provider);
        }
        const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
        return collectionContract.getRoyaltyParams();
    }
    async getNftItemRoyaltyParams(provider) {
        const { stack } = await provider.get('get_royalty_params', []);
        return {
            numerator: stack.readBigNumber(),
            denominator: stack.readBigNumber(),
            recipient: stack.readAddress(),
        };
    }
    async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
            const state = await provider.getState();
            if (!state.last) {
                return [];
            }
            lt = state.last.lt;
            hash = state.last.hash;
        }
        const transactions = await provider.getTransactions(this.address, lt, hash, limit);
        return transactions.map(tx => (0, NftItemAction_1.parseNftItemTransaction)(tx));
    }
}
exports.NftItem = NftItem;
NftItem.nftCode = core_1.Cell.fromBase64(nft_item_1.nftItemCode.codeBoc);
