"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NftCollection = exports.nftCollectionConfigToCell = void 0;
const core_1 = require("@ton/core");
const NftCollectionBase_1 = require("./NftCollectionBase");
const NftItem_1 = require("./NftItem");
const NftCollectionData_1 = require("./types/NftCollectionData");
const NftItemParams_1 = require("./types/NftItemParams");
const NftCollectionAction_1 = require("./types/NftCollectionAction");
function nftCollectionConfigToCell(config) {
    return (0, core_1.beginCell)().store((0, NftCollectionData_1.storeNftCollectionData)({
        admin: config.admin,
        content: config.content,
        itemCode: config.itemCode ?? NftItem_1.NftItem.nftCode,
        royalty: {
            numerator: config.royalty?.numerator ?? 0n,
            denominator: config.royalty?.denominator ?? 1n,
            recipient: config.royalty?.recipient ?? config.admin,
        },
    })).endCell();
}
exports.nftCollectionConfigToCell = nftCollectionConfigToCell;
class NftCollection extends NftCollectionBase_1.NftCollectionBase {
    static createFromConfig(config, code, workchain, contentResolver) {
        const data = nftCollectionConfigToCell(config);
        const init = { data, code: code ?? NftCollectionBase_1.NftCollectionBase.code };
        return new NftCollection((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver, (0, NftItemParams_1.createNftItemParamsValue)());
    }
    static createFromAddress(address, contentResolver) {
        return new NftCollection(address, undefined, contentResolver, (0, NftItemParams_1.createNftItemParamsValue)());
    }
    async getItem(provider, index) {
        const nftItemAddress = await this.getItemAddress(provider, index);
        return provider.open(new NftItem_1.NftItem(nftItemAddress, undefined, this.contentResolver));
    }
    async getRoyaltyParams(provider) {
        const { stack } = await provider.get('royalty_params', []);
        return {
            numerator: stack.readBigNumber(),
            denominator: stack.readBigNumber(),
            recipient: stack.readAddress(),
        };
    }
    async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
            const state = await provider.getState();
            if (!state.last) {
                return [];
            }
            lt = state.last.lt;
            hash = state.last.hash;
        }
        const messages = await provider.getTransactions(this.address, lt, hash, limit);
        return messages.map(tx => (0, NftCollectionAction_1.parseNftCollectionTransaction)(tx));
    }
}
exports.NftCollection = NftCollection;
