"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SbtCollection = exports.sbtCollectionConfigToCell = void 0;
const core_1 = require("@ton/core");
const NftCollectionBase_1 = require("./NftCollectionBase");
const SbtItem_1 = require("./SbtItem");
const SbtCollectionAction_1 = require("./types/SbtCollectionAction");
const NftCollectionData_1 = require("./types/NftCollectionData");
const SbtItemParams_1 = require("./types/SbtItemParams");
function sbtCollectionConfigToCell(config) {
    return (0, core_1.beginCell)().store((0, NftCollectionData_1.storeNftCollectionData)({
        admin: config.admin,
        content: config.content,
        itemCode: config.itemCode ?? SbtItem_1.SbtItem.sbtCode,
        royalty: {
            numerator: 0n,
            denominator: 1n,
            recipient: config.admin,
        },
    })).endCell();
}
exports.sbtCollectionConfigToCell = sbtCollectionConfigToCell;
class SbtCollection extends NftCollectionBase_1.NftCollectionBase {
    static createFromConfig(config, code, workchain, contentResolver) {
        const data = sbtCollectionConfigToCell(config);
        const init = { data, code: code ?? SbtCollection.code };
        return new SbtCollection((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver, (0, SbtItemParams_1.createSbtItemParamsValue)());
    }
    static createFromAddress(address, contentResolver) {
        return new SbtCollection(address, undefined, contentResolver, (0, SbtItemParams_1.createSbtItemParamsValue)());
    }
    async getItem(provider, index) {
        const nftItemAddress = await this.getItemAddress(provider, index);
        return provider.open(new SbtItem_1.SbtItem(nftItemAddress, undefined, this.contentResolver));
    }
    async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
            const state = await provider.getState();
            if (!state.last) {
                return [];
            }
            lt = state.last.lt;
            hash = state.last.hash;
        }
        const messages = await provider.getTransactions(this.address, lt, hash, limit);
        return messages.map(tx => (0, SbtCollectionAction_1.parseSbtCollectionTransaction)(tx));
    }
}
exports.SbtCollection = SbtCollection;
