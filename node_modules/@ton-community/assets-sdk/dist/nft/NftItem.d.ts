/// <reference types="node" />
import { Address, Cell, Contract, ContractProvider, Sender, StateInit } from "@ton/core";
import { ContentResolver } from "../content";
import { SendTransferOptions } from "../common/types";
import { NftRoyaltyParams } from "./types/NftRoyaltyParams";
import { NftItemParams } from "./types/NftItemParams";
import { NftItemAction } from "./types/NftItemAction";
import { NftItemData } from "./data";
export type NftItemConfig = {
    index: bigint;
    collection: Address;
};
export declare function nftItemConfigToCell(config: NftItemConfig): Cell;
export declare class NftItem implements Contract {
    readonly address: Address;
    readonly init?: StateInit | undefined;
    contentResolver?: ContentResolver | undefined;
    static nftCode: Cell;
    constructor(address: Address, init?: StateInit | undefined, contentResolver?: ContentResolver | undefined);
    static createFromConfig(config: NftItemConfig, code?: Cell, workchain?: number, contentResolver?: ContentResolver): NftItem;
    static createFromAddress(address: Address, contentResolver?: ContentResolver): NftItem;
    sendDeploy(provider: ContractProvider, sender: Sender, params: NftItemParams, value?: bigint): Promise<void>;
    send(provider: ContractProvider, sender: Sender, newOwner: Address, options?: SendTransferOptions & {
        customPayload?: Cell;
        value?: bigint;
        queryId?: bigint;
    }): Promise<void>;
    getData(provider: ContractProvider): Promise<NftItemData>;
    getContent(provider: ContractProvider): Promise<import("../content").ParsedContent<import("./content").ParsedNftContent>>;
    getRoyaltyParams(provider: ContractProvider): Promise<NftRoyaltyParams>;
    getNftItemRoyaltyParams(provider: ContractProvider): Promise<NftRoyaltyParams>;
    getActions(provider: ContractProvider, options?: {
        lt?: never;
        hash?: never;
        limit?: number;
    } | {
        lt: bigint;
        hash: Buffer;
        limit?: number;
    }): Promise<NftItemAction[]>;
}
