"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JettonWallet = exports.jettonWalletConfigToCell = void 0;
const core_1 = require("@ton/core");
const jetton_wallet_1 = require("./contracts/build/jetton-wallet");
const types_1 = require("../common/types");
const JettonTransferMessage_1 = require("./types/JettonTransferMessage");
const JettonBurnMessage_1 = require("./types/JettonBurnMessage");
const JettonWalletAction_1 = require("./types/JettonWalletAction");
function jettonWalletConfigToCell(config) {
    return (0, core_1.beginCell)()
        .storeCoins(config.balance)
        .storeAddress(config.owner)
        .storeAddress(config.jettonMaster)
        .storeRef(config.jettonWalletCode)
        .endCell();
}
exports.jettonWalletConfigToCell = jettonWalletConfigToCell;
class JettonWallet {
    constructor(address, init) {
        this.address = address;
        this.init = init;
    }
    static createFromConfig(config, code, workchain) {
        const data = jettonWalletConfigToCell({
            balance: 0n,
            owner: config.owner,
            jettonMaster: config.jettonMaster,
            jettonWalletCode: code ?? JettonWallet.code,
        });
        const init = { data, code: code ?? JettonWallet.code };
        return new JettonWallet((0, core_1.contractAddress)(workchain ?? 0, init), init);
    }
    static createFromAddress(address) {
        return new JettonWallet(address);
    }
    async sendDeploy(provider, sender, value) {
        await provider.internal(sender, {
            value: value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
        });
    }
    async send(provider, sender, recipient, amount, options) {
        const notification = (0, types_1.parseNotifyOptions)(options?.notify);
        const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
        await provider.internal(sender, {
            value: (options?.value ?? (0, core_1.toNano)('0.05')) + (notification?.amount ?? 0n),
            bounce: true,
            sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
            body: (0, core_1.beginCell)().store((0, JettonTransferMessage_1.storeJettonTransferMessage)({
                queryId: options?.queryId ?? 0n,
                amount: amount,
                destination: recipient,
                responseDestination: excessReturn?.address ?? null,
                customPayload: options?.customPayload ?? null,
                forwardAmount: notification?.amount ?? 0n,
                forwardPayload: notification?.payload ?? null,
            })).endCell(),
        });
    }
    async sendBurn(provider, sender, amount, options) {
        const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
        await provider.internal(sender, {
            value: options?.value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
            sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
            body: (0, core_1.beginCell)().store((0, JettonBurnMessage_1.storeJettonBurnMessage)({
                queryId: options?.queryId ?? 0n,
                amount: amount,
                responseDestination: excessReturn?.address ?? null,
                customPayload: options?.customPayload ?? null,
            })).endCell(),
        });
    }
    async getData(provider) {
        const { stack } = await provider.get('get_wallet_data', []);
        return {
            balance: stack.readBigNumber(),
            owner: stack.readAddress(),
            jettonMaster: stack.readAddress(),
            jettonWalletCode: stack.readCell(),
        };
    }
    async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
            const state = await provider.getState();
            if (!state.last) {
                return [];
            }
            lt = state.last.lt;
            hash = state.last.hash;
        }
        const transactions = await provider.getTransactions(this.address, lt, hash, limit);
        return transactions.map(tx => (0, JettonWalletAction_1.parseJettonWalletTransaction)(tx));
    }
}
exports.JettonWallet = JettonWallet;
JettonWallet.code = core_1.Cell.fromBase64(jetton_wallet_1.jettonWalletCode.codeBoc);
