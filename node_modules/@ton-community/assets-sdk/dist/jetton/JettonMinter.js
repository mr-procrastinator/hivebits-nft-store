"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JettonMinter = exports.jettonMinterConfigToCell = void 0;
const core_1 = require("@ton/core");
const JettonWallet_1 = require("./JettonWallet");
const content_1 = require("../content");
const content_2 = require("./content");
const jetton_minter_1 = require("./contracts/build/jetton-minter");
const types_1 = require("../common/types");
const JettonMintMessage_1 = require("./types/JettonMintMessage");
const JettonMinterContent_1 = require("./types/JettonMinterContent");
const JettonChangeAdminMessage_1 = require("./types/JettonChangeAdminMessage");
const JettonChangeContentMessage_1 = require("./types/JettonChangeContentMessage");
const JettonMinterAction_1 = require("./types/JettonMinterAction");
function jettonMinterConfigToCell(config) {
    return (0, core_1.beginCell)().store((0, JettonMinterContent_1.storeJettonMinterContent)({
        admin: config.admin,
        content: config.content,
        jettonWalletCode: config.jettonWalletCode ?? JettonWallet_1.JettonWallet.code,
    })).endCell();
}
exports.jettonMinterConfigToCell = jettonMinterConfigToCell;
class JettonMinter {
    constructor(address, init, contentResolver) {
        this.address = address;
        this.init = init;
        this.contentResolver = contentResolver;
    }
    static createFromAddress(address, contentResolver) {
        return new JettonMinter(address, undefined, contentResolver);
    }
    static createFromConfig(config, code, workchain, contentResolver) {
        const data = jettonMinterConfigToCell(config);
        const init = { data, code: code ?? JettonMinter.code };
        return new JettonMinter((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
    }
    async sendDeploy(provider, sender, value) {
        await provider.internal(sender, {
            value: value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
        });
    }
    async sendMint(provider, sender, recipient, amount, options) {
        const notification = (0, types_1.parseNotifyOptions)(options?.notify);
        const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
        await provider.internal(sender, {
            value: options?.value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
            body: (0, core_1.beginCell)().store((0, JettonMintMessage_1.storeJettonMintMessage)({
                queryId: options?.queryId ?? 0n,
                amount: amount,
                from: this.address,
                to: recipient,
                responseAddress: excessReturn?.address ?? null,
                forwardPayload: notification?.payload ?? null,
                forwardTonAmount: notification?.amount ?? 0n,
                walletForwardValue: (notification?.amount ?? 0n) + (excessReturn ? (0, core_1.toNano)('0.01') : 0n) + (0, core_1.toNano)(0.02),
            })).endCell(),
        });
    }
    async sendChangeAdmin(provider, sender, newAdmin, options) {
        await provider.internal(sender, {
            value: options?.value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
            body: (0, core_1.beginCell)().store((0, JettonChangeAdminMessage_1.storeJettonChangeAdminMessage)({
                queryId: options?.queryId ?? 0n,
                newAdmin: newAdmin,
            })).endCell(),
        });
    }
    async sendChangeContent(provider, sender, newContent, options) {
        await provider.internal(sender, {
            value: options?.value ?? (0, core_1.toNano)('0.05'),
            bounce: true,
            body: (0, core_1.beginCell)().store((0, JettonChangeContentMessage_1.storeJettonChangeContentMessage)({
                queryId: options?.queryId ?? 0n,
                newContent: newContent,
            })).endCell(),
        });
    }
    async getData(provider) {
        const builder = new core_1.TupleBuilder();
        const { stack } = await provider.get('get_jetton_data', builder.build());
        return {
            totalSupply: stack.readBigNumber(),
            mintable: stack.readBigNumber() !== 0n,
            adminAddress: stack.readAddressOpt(),
            jettonContent: stack.readCell(),
            jettonWalletCode: stack.readCell(),
        };
    }
    async getWalletAddress(provider, owner) {
        const builder = new core_1.TupleBuilder();
        builder.writeAddress(owner);
        const { stack } = await provider.get('get_wallet_address', builder.build());
        return stack.readAddress();
    }
    async getWallet(provider, owner) {
        const jettonWalletAddress = await this.getWalletAddress(provider, owner);
        return provider.open(new JettonWallet_1.JettonWallet(jettonWalletAddress));
    }
    async getContent(provider) {
        if (!this.contentResolver) {
            throw new Error('No content resolver');
        }
        const data = await this.getData(provider);
        return (0, content_2.parseJettonContent)(await (0, content_1.loadFullContent)(data.jettonContent, this.contentResolver));
    }
    async getActions(provider, options) {
        let { lt, hash, limit } = options ?? {};
        if (!lt || !hash) {
            const state = await provider.getState();
            if (!state.last) {
                return [];
            }
            lt = state.last.lt;
            hash = state.last.hash;
        }
        const transactions = await provider.getTransactions(this.address, lt, hash, limit);
        return transactions.map(tx => (0, JettonMinterAction_1.parseJettonMinterTransaction)(tx));
    }
}
exports.JettonMinter = JettonMinter;
JettonMinter.code = core_1.Cell.fromBase64(jetton_minter_1.jettonMinterCode.codeBoc);
