/// <reference types="node" />
import { Address, Cell, Contract, ContractProvider, Sender, StateInit } from "@ton/core";
import { SendTransferOptions } from "../common/types";
import { PartialBy } from "../utils";
import { JettonWalletAction } from "./types/JettonWalletAction";
import { JettonWalletData } from "./types/JettonWalletData";
export declare function jettonWalletConfigToCell(config: JettonWalletData): Cell;
export type JettonWalletConfig = Omit<PartialBy<JettonWalletData, 'jettonWalletCode'>, 'balance'>;
export declare class JettonWallet implements Contract {
    readonly address: Address;
    readonly init?: StateInit | undefined;
    static code: Cell;
    constructor(address: Address, init?: StateInit | undefined);
    static createFromConfig(config: JettonWalletConfig, code?: Cell, workchain?: number): JettonWallet;
    static createFromAddress(address: Address): JettonWallet;
    sendDeploy(provider: ContractProvider, sender: Sender, value?: bigint): Promise<void>;
    send(provider: ContractProvider, sender: Sender, recipient: Address, amount: bigint, options?: SendTransferOptions & {
        customPayload?: Cell;
        value?: bigint;
        queryId?: bigint;
    }): Promise<void>;
    sendBurn(provider: ContractProvider, sender: Sender, amount: bigint, options?: Pick<SendTransferOptions, 'returnExcess'> & {
        customPayload?: Cell;
        value?: bigint;
        queryId?: bigint;
    }): Promise<void>;
    getData(provider: ContractProvider): Promise<JettonWalletData>;
    getActions(provider: ContractProvider, options?: {
        lt?: never;
        hash?: never;
        limit?: number;
    } | {
        lt: bigint;
        hash: Buffer;
        limit?: number;
    }): Promise<JettonWalletAction[]>;
}
