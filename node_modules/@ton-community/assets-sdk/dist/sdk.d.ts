import { Address, Sender } from "@ton/core";
import { Storage } from "./storage/storage";
import { PinataStorageParams } from "./storage/pinata";
import { S3StorageParams } from "./storage/s3";
import { TonClientApi } from "./client/ton-client-api";
import { JettonContent } from "./jetton/content";
import { NftContent } from "./nft/content";
import { JettonWallet } from "./jetton/JettonWallet";
import { JettonMinter } from "./jetton/JettonMinter";
import { NftCollection } from "./nft/NftCollection";
import { NftItem } from "./nft/NftItem";
import { SbtCollection } from "./nft/SbtCollection";
import { NftSaleParams } from "./nft/data";
import { ContentResolver } from "./content";
import { NftSale } from "./nft/NftSale";
import { SendTransferOptions } from "./common/types";
import { NftRoyaltyParams } from "./nft/types/NftRoyaltyParams";
import { NftMintItemParams } from "./nft/types/NftBatchMintMessage";
import { SbtItemParams } from "./nft/types/SbtItemParams";
import { NftItemParams } from "./nft/types/NftItemParams";
type DeployJettonOptions = {
    onchainContent?: boolean;
    adminAddress?: Address;
    premintAmount?: bigint;
    premintOptions?: SendTransferOptions;
    value?: bigint;
    queryId?: bigint;
};
export declare class AssetsSDK {
    readonly storage: Storage;
    readonly api: TonClientApi;
    readonly sender?: Sender | undefined;
    readonly contentResolver?: ContentResolver | undefined;
    constructor(storage: Storage, api: TonClientApi, sender?: Sender | undefined, contentResolver?: ContentResolver | undefined);
    static create(params: {
        api: TonClientApi;
        storage?: PinataStorageParams | S3StorageParams | Storage;
        sender?: Sender;
        contentResolver?: ContentResolver;
    }): AssetsSDK;
    deployJetton(content: JettonContent, options?: DeployJettonOptions): Promise<import("@ton/core").OpenedContract<JettonMinter>>;
    openJetton(address: Address): import("@ton/core").OpenedContract<JettonMinter>;
    deployNftCollection(content: {
        collectionContent: NftContent;
        commonContent: string;
    }, options?: {
        royaltyParams?: NftRoyaltyParams;
        adminAddress?: Address;
        onchainContent?: boolean;
        premintItems?: NftMintItemParams<NftItemParams>[];
        value?: bigint;
        queryId?: bigint;
    }): Promise<import("@ton/core").OpenedContract<NftCollection>>;
    openNftCollection(address: Address): import("@ton/core").OpenedContract<NftCollection>;
    deploySbtCollection(content: {
        collectionContent: NftContent;
        commonContent: string;
        onchainContent?: boolean;
    }, options?: {
        adminAddress?: Address;
        premintItems?: NftMintItemParams<SbtItemParams>[];
        value?: bigint;
        queryId?: bigint;
    }): Promise<import("@ton/core").OpenedContract<SbtCollection>>;
    openSbtCollection(address: Address): import("@ton/core").OpenedContract<SbtCollection>;
    openJettonWallet(address: Address): import("@ton/core").OpenedContract<JettonWallet>;
    openNftItem(address: Address): import("@ton/core").OpenedContract<NftItem>;
    deployNftSale(params: NftSaleParams): Promise<import("@ton/core").OpenedContract<NftSale>>;
    openNftSale(address: Address): import("@ton/core").OpenedContract<NftSale>;
    private internalOffchainContentToCell;
    private contentToCell;
}
export {};
