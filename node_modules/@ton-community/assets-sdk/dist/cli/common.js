"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.retry = exports.formatAddressLink = exports.formatAddress = exports.printAddress = exports.printInfo = exports.createEnv = exports.createContentResolver = exports.createStorageEnv = void 0;
const core_1 = require("@ton/core");
const __1 = require("..");
const content_1 = require("../content");
const chalk_1 = __importDefault(require("chalk"));
const boxen_1 = __importDefault(require("boxen"));
function createStorageEnv() {
    if (process.env.STORAGE_TYPE === undefined)
        throw new Error('No STORAGE_TYPE in env!');
    if (process.env.STORAGE_TYPE === 'pinata') {
        if (process.env.PINATA_API_KEY === undefined)
            throw new Error('No PINATA_API_KEY in env!');
        if (process.env.PINATA_SECRET_KEY === undefined)
            throw new Error('No PINATA_SECRET_KEY in env!');
        return new __1.PinataStorage(process.env.PINATA_API_KEY, process.env.PINATA_SECRET_KEY);
    }
    else if (process.env.STORAGE_TYPE === 's3') {
        if (process.env.S3_ACCESS_KEY_ID === undefined)
            throw new Error('No S3_ACCESS_KEY_ID in env!');
        if (process.env.S3_SECRET_ACCESS_KEY === undefined)
            throw new Error('No S3_SECRET_ACCESS_KEY in env!');
        if (process.env.S3_BUCKET === undefined)
            throw new Error('No S3_BUCKET in env!');
        return new __1.S3Storage(process.env.S3_ACCESS_KEY_ID, process.env.S3_SECRET_ACCESS_KEY, process.env.S3_BUCKET);
    }
    throw new Error(`Unknown storage type: ${process.env.STORAGE_TYPE}`);
}
exports.createStorageEnv = createStorageEnv;
function createContentResolver() {
    if (process.env.IPFS_GATEWAY_TYPE === undefined)
        throw new Error('No IPFS_GATEWAY_TYPE in env!');
    if (process.env.IPFS_GATEWAY_TYPE === 'ipfs.io') {
        return new content_1.DefaultContentResolver((id) => `https://ipfs.io/ipfs/${id}`);
    }
    if (process.env.IPFS_GATEWAY_TYPE === 'https') {
        if (process.env.IPFS_GATEWAY === undefined)
            throw new Error('No IPFS_GATEWAY in env!');
        const ipfsGateway = new URL(process.env.IPFS_GATEWAY);
        return new content_1.DefaultContentResolver((id) => {
            ipfsGateway.pathname = '/ipfs/' + id;
            return ipfsGateway.toString();
        });
    }
    if (process.env.IPFS_GATEWAY_TYPE === 'pinata') {
        if (process.env.IPFS_GATEWAY === undefined)
            throw new Error('No IPFS_GATEWAY in env!');
        if (process.env.IPFS_GATEWAY_API_KEY === undefined)
            throw new Error('No IPFS_GATEWAY_API_KEY in env!');
        const ipfsGateway = new URL(process.env.IPFS_GATEWAY);
        return new content_1.DefaultContentResolver((id) => {
            ipfsGateway.pathname = '/ipfs/' + id;
            ipfsGateway.searchParams.set('pinataGatewayToken', process.env.IPFS_GATEWAY_API_KEY);
            return ipfsGateway.toString();
        });
    }
    throw new Error(`Unknown IPFS gateway type: ${process.env.IPFS_GATEWAY_TYPE}`);
}
exports.createContentResolver = createContentResolver;
async function createEnv() {
    if (process.env.WALLET_TYPE === undefined)
        throw new Error('No WALLET_TYPE in env!');
    if (process.env.WALLET_TYPE !== 'highload-v2')
        throw new Error(`Unknown wallet type: ${process.env.WALLET_TYPE}`);
    if (process.env.MNEMONIC === undefined)
        throw new Error('No MNEMONIC in env!');
    if (process.env.NETWORK === undefined)
        throw new Error('No NETWORK in env!');
    if (process.env.NETWORK !== 'mainnet' && process.env.NETWORK !== 'testnet')
        throw new Error(`Unknown network: ${process.env.NETWORK}`);
    const contentResolver = createContentResolver();
    const storage = createStorageEnv();
    const client = await (0, __1.createApi)(process.env.NETWORK);
    const keyPair = await (0, __1.importKey)(process.env.MNEMONIC);
    const { publicKey, secretKey } = keyPair;
    const walletContract = await (0, __1.createWallet)(process.env.WALLET_TYPE, publicKey);
    const sender = client.open(walletContract).sender(keyPair.secretKey);
    const sdk = __1.AssetsSDK.create({
        storage,
        api: client,
        sender: sender,
        contentResolver
    });
    return {
        sdk,
        network: process.env.NETWORK,
        storage: storage,
        sender: sender,
        client: client,
    };
}
exports.createEnv = createEnv;
function printInfo(info, network) {
    const keys = Object.keys(info);
    const rows = [];
    for (const key of keys) {
        let value = info[key];
        if (typeof value === 'string') {
            value = chalk_1.default.green(value);
        }
        else if (typeof value === 'bigint') {
            value = chalk_1.default.yellow(value.toString());
        }
        else if (typeof value === 'number') {
            value = chalk_1.default.cyan(value);
        }
        else if (typeof value === 'boolean') {
            value = chalk_1.default.blue(value);
        }
        else if (value === null) {
            value = chalk_1.default.red('null');
        }
        else if (value === undefined) {
            value = chalk_1.default.red('undefined');
        }
        else if (core_1.Address.isAddress(value)) {
            value = `${chalk_1.default.magenta(formatAddress(value, network))} ${chalk_1.default.blue(formatAddressLink(value, network))}`;
        }
        else if (value instanceof core_1.Cell) {
            value = chalk_1.default.blue(value.toString('base64'));
        }
        else {
            throw new Error(`Unknown type: ${typeof value}`);
        }
        rows.push([key, value]);
    }
    console.log((0, boxen_1.default)(rows.filter(([key]) => key !== 'name').map(([key, value]) => `${chalk_1.default.bold(key)}: ${value}`).join('\n'), {
        padding: {
            top: 0,
            bottom: 0,
            left: 1,
            right: 1,
        },
        borderStyle: 'round',
        borderColor: 'green',
        title: rows.find(([key, value]) => key === 'name')?.[1],
    }));
}
exports.printInfo = printInfo;
function printAddress(address, network, name = 'wallet') {
    const formattedAddress = formatAddress(address, network);
    const formattedAddressLink = formatAddressLink(address, network);
    console.log(`Your ${name} has the address ${formattedAddress}
You can view it at ${formattedAddressLink}`);
}
exports.printAddress = printAddress;
function formatAddress(address, network) {
    if (!address) {
        return 'null';
    }
    return address.toString({ testOnly: network === 'testnet', bounceable: true });
}
exports.formatAddress = formatAddress;
function formatAddressLink(address, network) {
    if (!address) {
        return 'null';
    }
    return `https://${network === 'testnet' ? 'testnet.' : ''}tonviewer.com/${formatAddress(address, network)}`;
}
exports.formatAddressLink = formatAddressLink;
async function retry(fn, options) {
    let { retries, delay, name } = { retries: 3, delay: 1000, ...options };
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        }
        catch (e) {
            console.log(`Attempt ${i + 1} failed: ${name ? name + ': ' : ''}${e}`);
        }
        await new Promise(resolve => setTimeout(resolve, delay * 2 ** i));
    }
    throw new Error('Exceeded number of retries');
}
exports.retry = retry;
