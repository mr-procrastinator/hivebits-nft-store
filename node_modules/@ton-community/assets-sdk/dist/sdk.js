"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsSDK = void 0;
const core_1 = require("@ton/core");
const pinata_1 = require("./storage/pinata");
const s3_1 = require("./storage/s3");
const content_1 = require("./jetton/content");
const content_2 = require("./nft/content");
const utils_1 = require("./utils");
const JettonWallet_1 = require("./jetton/JettonWallet");
const JettonMinter_1 = require("./jetton/JettonMinter");
const NftCollection_1 = require("./nft/NftCollection");
const NftItem_1 = require("./nft/NftItem");
const SbtCollection_1 = require("./nft/SbtCollection");
const content_3 = require("./content");
const NftSale_1 = require("./nft/NftSale");
const noop_1 = require("./storage/noop");
const common_1 = require("./cli/common");
const WORKCHAIN = 0;
class AssetsSDK {
    constructor(storage, api, sender, contentResolver) {
        this.storage = storage;
        this.api = api;
        this.sender = sender;
        this.contentResolver = contentResolver;
    }
    static create(params) {
        let { api, storage, sender: sender, contentResolver } = params;
        if (!storage) {
            storage = new noop_1.NoopStorage();
        }
        else if ('pinataApiKey' in storage) {
            storage = pinata_1.PinataStorage.create(storage);
        }
        else if ('s3AccessKeyId' in storage) {
            storage = s3_1.S3Storage.create(storage);
        }
        contentResolver ?? (contentResolver = new content_3.DefaultContentResolver());
        return new AssetsSDK(storage, api, sender, contentResolver);
    }
    async deployJetton(content, options) {
        if (!this.sender) {
            throw new Error('Sender must be defined');
        }
        const adminAddress = options?.adminAddress ?? this.sender?.address;
        if (adminAddress === undefined) {
            throw new Error('Admin address must be defined in options or be available in Sender');
        }
        const jettonMinterContract = JettonMinter_1.JettonMinter.createFromConfig({
            admin: adminAddress,
            content: await this.contentToCell((0, content_1.jettonContentToInternal)(content), options?.onchainContent ?? false),
        }, JettonMinter_1.JettonMinter.code, WORKCHAIN, this.contentResolver);
        const jetton = this.api.open(jettonMinterContract);
        const premintAmount = options?.premintAmount;
        if (typeof premintAmount === 'bigint' && premintAmount > 0n) {
            await jetton.sendMint(this.sender, adminAddress, premintAmount, {
                ...options?.premintOptions,
                value: options?.value,
                queryId: options?.queryId
            });
        }
        else {
            await jetton.sendDeploy(this.sender, options?.value);
        }
        return jetton;
    }
    openJetton(address) {
        return this.api.open(JettonMinter_1.JettonMinter.createFromAddress(address, this.contentResolver));
    }
    async deployNftCollection(content, options) {
        if (!this.sender) {
            throw new Error('Sender must be defined');
        }
        const adminAddress = options?.adminAddress ?? this.sender?.address;
        if (adminAddress === undefined) {
            throw new Error('Admin address must be defined in options or be available in Sender');
        }
        const collection = this.api.open(NftCollection_1.NftCollection.createFromConfig({
            admin: adminAddress,
            content: (0, core_1.beginCell)()
                .storeRef(await this.contentToCell((0, content_2.nftContentToInternal)(content.collectionContent), options?.onchainContent ?? false))
                .storeRef((0, core_1.beginCell)().storeStringTail(content.commonContent))
                .endCell(),
            royalty: options?.royaltyParams,
        }, NftCollection_1.NftCollection.code, WORKCHAIN, this.contentResolver));
        if (typeof options?.premintItems?.length === 'number' && options?.premintItems.length > 0) {
            await collection.sendBatchMint(this.sender, options?.premintItems, {
                value: options?.value,
                queryId: options?.queryId
            });
        }
        else {
            await collection.sendDeploy(this.sender, options?.value);
        }
        return collection;
    }
    openNftCollection(address) {
        return this.api.open(NftCollection_1.NftCollection.createFromAddress(address, this.contentResolver));
    }
    async deploySbtCollection(content, options) {
        if (!this.sender) {
            throw new Error('Sender must be defined');
        }
        const adminAddress = options?.adminAddress ?? this.sender?.address;
        if (adminAddress === undefined) {
            throw new Error('Admin address must be defined in options or be available in Sender');
        }
        const collection = this.api.open(SbtCollection_1.SbtCollection.createFromConfig({
            admin: adminAddress,
            content: (0, core_1.beginCell)()
                .storeRef(await this.contentToCell((0, content_2.nftContentToInternal)(content.collectionContent), content?.onchainContent ?? false))
                .storeRef((0, core_1.beginCell)().storeStringTail(content.commonContent))
                .endCell(),
        }, SbtCollection_1.SbtCollection.code, WORKCHAIN, this.contentResolver));
        if (typeof options?.premintItems?.length === 'number' && options?.premintItems.length > 0) {
            await collection.sendBatchMint(this.sender, options?.premintItems, {
                value: options?.value,
                queryId: options?.queryId
            });
        }
        else {
            await collection.sendDeploy(this.sender, options?.value);
        }
        return collection;
    }
    openSbtCollection(address) {
        return this.api.open(SbtCollection_1.SbtCollection.createFromAddress(address, this.contentResolver));
    }
    openJettonWallet(address) {
        return this.api.open(new JettonWallet_1.JettonWallet(address));
    }
    openNftItem(address) {
        return this.api.open(new NftItem_1.NftItem(address, undefined, this.contentResolver));
    }
    async deployNftSale(params) {
        if (!this.sender) {
            throw new Error('Sender must be defined');
        }
        const marketplaceAddress = params.marketplace ?? this.sender?.address;
        if (marketplaceAddress === undefined) {
            throw new Error('Marketplace address must be defined in options or be available in Sender');
        }
        const sale = this.api.open(NftSale_1.NftSale.createFromConfig({
            createdAt: params.createdAt ?? Math.floor(Date.now() / 1000),
            marketplace: params.marketplace ?? null,
            nft: params.nft,
            fullPrice: params.fullPrice,
            marketplaceFeeTo: params.marketplaceFeeTo ?? null,
            marketplaceFee: params.marketplaceFee ?? 0n,
            royaltyTo: params.royaltyTo ?? null,
            royalty: params.royalty ?? 0n,
            canDeployByExternal: params.canDeployByExternal ?? true,
        }));
        await sale.sendTopup(this.sender, { value: params.value, queryId: params.queryId });
        return sale;
    }
    openNftSale(address) {
        return this.api.open(NftSale_1.NftSale.createFromAddress(address));
    }
    async internalOffchainContentToCell(internal) {
        const contents = Buffer.from(JSON.stringify(internal), 'utf-8');
        const contentUrl = await (0, common_1.retry)(() => this.storage.uploadFile(contents), { name: 'upload content' });
        return (0, core_1.beginCell)()
            .storeUint(0x01, 8)
            .storeStringTail(contentUrl)
            .endCell();
    }
    async contentToCell(internal, onchain) {
        return onchain ? (0, utils_1.internalOnchainContentToCell)(internal) : await this.internalOffchainContentToCell(internal);
    }
}
exports.AssetsSDK = AssetsSDK;
